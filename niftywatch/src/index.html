<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>NIFTY 50 Dashboard</title>
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: 'Segoe UI', Arial, sans-serif;
                background: linear-gradient(135deg, #1a1a2e, #16213e);
                color: #fff;
                overflow-x: hidden;
            }

            .dashboard-container {
                display: grid;
                grid-template-columns: 300px 1fr;
                height: 100vh;
                gap: 20px;
                padding: 20px;
                box-sizing: border-box;
                overflow: hidden;
            }

            .sidebar {
                background: rgba(0, 0, 0, 0.3);
                border-radius: 12px;
                padding: 20px;
                border: 1px solid rgba(59, 130, 246, 0.3);
                backdrop-filter: blur(10px);
                overflow-y: auto;
                box-sizing: border-box;
            }

            .main-content {
                display: flex;
                flex-direction: column;
                gap: 15px;
                height: 100%;
                overflow: hidden;
            }

            .charts-container {
                flex: 1;
                display: flex;
                flex-direction: column;
                gap: 15px;
                overflow: hidden;
            }

            .controls {
                display: flex;
                gap: 15px;
                align-items: center;
                flex-wrap: wrap;
                justify-content: space-between;
                flex-shrink: 0;
                min-height: 50px;
            }

            .controls-left {
                display: flex;
                gap: 15px;
                align-items: center;
                flex-wrap: wrap;
            }

            .dashboard-title {
                color: #3b82f6;
                font-size: 20px;
                font-weight: 700;
                display: flex;
                flex-direction: column;
                align-items: flex-end;
                gap: 4px;
                margin: 0;
                min-width: 300px;
                position: relative;
                z-index: 10;
            }

            .title-main {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .chart-mode-buttons {
                display: flex;
                gap: 4px;
                margin-right: 8px;
            }

            .chart-mode-btn {
                background: linear-gradient(45deg, #374151, #4b5563);
                color: #ffffff;
                border: 1px solid rgba(59, 130, 246, 0.3);
                padding: 6px 12px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 600;
                font-size: 14px;
                transition: all 0.3s ease;
                min-width: 32px;
                height: 32px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .chart-mode-btn:hover {
                background: linear-gradient(45deg, #4b5563, #6b7280);
                border-color: #3b82f6;
                transform: translateY(-1px);
                box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
            }

            .chart-mode-btn.active {
                background: linear-gradient(45deg, #3b82f6, #1d4ed8);
                border-color: #3b82f6;
                box-shadow: 0 2px 8px rgba(59, 130, 246, 0.5);
            }

            .chart-mode-btn.active:hover {
                background: linear-gradient(45deg, #1d4ed8, #1e40af);
            }

            .chart-mode-btn.disabled {
                background: linear-gradient(45deg, #1f2937, #374151);
                border-color: #4b5563;
                color: #6b7280;
                cursor: not-allowed;
                opacity: 0.5;
            }

            .chart-mode-btn.disabled:hover {
                background: linear-gradient(45deg, #1f2937, #374151);
                border-color: #4b5563;
                transform: none;
                box-shadow: none;
            }

            .title-stats-inline {
                display: flex;
                align-items: center;
                justify-content: flex-end;
                gap: 8px;
                font-size: 14px;
                margin-top: 4px;
            }

            .data-date {
                color: #94a3b8;
                font-size: 14px;
                font-weight: 500;
            }

            .title-separator {
                color: #64748b;
                font-weight: bold;
                margin: 0 4px;
            }

            .title-stat {
                color: #ffffff;
                font-weight: 600;
            }

            .title-stat .stat-value {
                font-size: 14px;
                font-weight: bold;
                margin-left: 4px;
            }

            .live-indicator {
                width: 6px;
                height: 6px;
                background: #10b981;
                border-radius: 50%;
                animation: pulse 2s infinite;
            }

            @keyframes pulse {
                0% {
                    opacity: 1;
                }

                50% {
                    opacity: 0.5;
                }

                100% {
                    opacity: 1;
                }
            }

            .timeframe-btn,
            .zoom-btn {
                background: linear-gradient(45deg, #3b82f6, #1d4ed8);
                color: white;
                border: none;
                padding: 10px 16px;
                border-radius: 8px;
                cursor: pointer;
                font-weight: 600;
                font-size: 14px;
                transition: all 0.3s ease;
                box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
            }

            .timeframe-btn:hover,
            .zoom-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 16px rgba(59, 130, 246, 0.5);
            }

            .timeframe-btn.active {
                background: linear-gradient(45deg, #10b981, #059669);
                box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
            }

            .index-selector {
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .index-selector label {
                color: #94a3b8;
                font-weight: 600;
                font-size: 14px;
            }

            .index-dropdown {
                background: linear-gradient(45deg, #1f2937, #374151);
                color: #ffffff;
                border: 1px solid rgba(59, 130, 246, 0.5);
                padding: 10px 16px;
                border-radius: 8px;
                cursor: pointer;
                font-weight: 600;
                font-size: 14px;
                transition: all 0.3s ease;
                box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
            }

            .index-dropdown:hover,
            .index-dropdown:focus {
                border-color: #3b82f6;
                box-shadow: 0 4px 16px rgba(59, 130, 246, 0.5);
                outline: none;
                background: linear-gradient(45deg, #374151, #4b5563);
            }

            .index-dropdown option {
                background-color: #1f2937;
                color: #ffffff;
                padding: 10px;
                border: none;
            }

            .index-dropdown option:hover,
            .index-dropdown option:checked {
                background-color: #3b82f6;
                color: #ffffff;
            }

            .date-selector {
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .date-selector label {
                color: #94a3b8;
                font-weight: 600;
                font-size: 14px;
            }

            .date-input {
                background: linear-gradient(45deg, #1f2937, #374151);
                color: #ffffff;
                border: 1px solid rgba(59, 130, 246, 0.5);
                padding: 10px 16px;
                border-radius: 8px;
                cursor: pointer;
                font-weight: 600;
                font-size: 14px;
                transition: all 0.3s ease;
                box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
            }

            .date-input:hover,
            .date-input:focus {
                border-color: #3b82f6;
                box-shadow: 0 4px 16px rgba(59, 130, 246, 0.5);
                outline: none;
                background: linear-gradient(45deg, #374151, #4b5563);
            }

            .date-input::-webkit-calendar-picker-indicator {
                filter: invert(1);
                cursor: pointer;
            }

            .refresh-btn {
                background: linear-gradient(45deg, #10b981, #059669);
                color: #ffffff;
                border: 1px solid rgba(16, 185, 129, 0.5);
                padding: 10px;
                border-radius: 8px;
                cursor: pointer;
                margin-left: 8px;
                transition: all 0.3s ease;
                box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
                display: inline-flex;
                align-items: center;
                justify-content: center;
                width: 40px;
                height: 40px;
            }

            .refresh-btn:hover {
                background: linear-gradient(45deg, #059669, #047857);
                border-color: #10b981;
                box-shadow: 0 4px 16px rgba(16, 185, 129, 0.5);
                transform: translateY(-1px);
            }

            .refresh-btn:active {
                transform: translateY(0);
                box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
            }

            .refresh-btn svg {
                transition: transform 0.3s ease;
            }

            .refresh-btn:hover svg {
                transform: rotate(45deg);
            }

            @keyframes spin {
                from {
                    transform: rotate(0deg);
                }

                to {
                    transform: rotate(360deg);
                }
            }

            .refresh-btn:disabled {
                opacity: 0.7;
                cursor: not-allowed;
            }

            .chart-container {
                flex: 0.5;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 12px;
                border: 1px solid rgba(59, 130, 246, 0.3);
                position: relative;
                min-height: 300px;
                display: flex;
                flex-direction: column;
            }

            .chart-container #chart {
                flex: 1;
                width: 100%;
                min-height: 0;
            }

            .secondary-charts-container {
                flex: 0.5;
                display: flex;
                gap: 15px;
                min-height: 300px;
            }

            .secondary-chart {
                flex: 1;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 12px;
                border: 1px solid rgba(59, 130, 246, 0.3);
                position: relative;
                display: flex;
                flex-direction: column;
            }

            .secondary-chart-title {
                color: #3b82f6;
                font-size: 16px;
                font-weight: 600;
                padding: 15px 20px 10px;
                border-bottom: 1px solid rgba(59, 130, 246, 0.2);
                background: rgba(0, 0, 0, 0.2);
                border-radius: 12px 12px 0 0;
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-shrink: 0;
                width: 100%;
                box-sizing: border-box;
            }

            .chart-overlay-controls {
                display: flex;
                gap: 8px;
                align-items: center;
            }

            .secondary-chart-content {
                flex: 1;
                padding: 15px;
                display: flex;
                align-items: center;
                justify-content: center;
                color: #94a3b8;
                font-size: 14px;
                position: relative;
                min-height: 200px;
                width: 100%;
                box-sizing: border-box;
            }

            /* Ensure chart elements can expand to fill available space */
            .secondary-chart-content#oi-chart,
            .secondary-chart-content#sentiment-chart {
                width: 100% !important;
                height: 100% !important;
                min-height: 0;
                flex: 1;
            }

            /* Full-size mode adjustments */
            .chart-container.full-size,
            .secondary-chart.full-size {
                min-height: calc(100vh - 200px) !important;
                height: calc(100vh - 200px) !important;
                flex: 1 !important;
            }

            .chart-container.full-size #chart,
            .secondary-chart.full-size .secondary-chart-content {
                min-height: calc(100vh - 250px) !important;
                height: calc(100vh - 250px) !important;
                flex: 1 !important;
            }

            /* Enhanced full-size mode for Charts 2 & 3 */
            .secondary-chart.full-size {
                width: 100% !important;
                height: calc(100vh - 180px) !important;
                min-height: calc(100vh - 180px) !important;
                max-width: none !important;
                max-height: none !important;
            }
            
            .secondary-chart.full-size .secondary-chart-content {
                padding: 10px !important;
                height: calc(100vh - 220px) !important;
                min-height: calc(100vh - 220px) !important;
            }
            
            .secondary-chart.full-size .secondary-chart-content#oi-chart,
            .secondary-chart.full-size .secondary-chart-content#sentiment-chart {
                width: 100% !important;
                height: 100% !important;
                min-height: calc(100vh - 250px) !important;
                min-width: calc(100vw - 350px) !important;
            }
            
            /* Secondary charts container when in full-size mode */
            .secondary-charts-container.full-size-container {
                position: relative !important;
                width: 100% !important;
                height: calc(100vh - 160px) !important;
                min-height: calc(100vh - 160px) !important;
            }

            .chart-container {
                flex: 1;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 12px;
                border: 1px solid rgba(59, 130, 246, 0.3);
                position: relative;
            }

            #chart {
                width: 100%;
                height: 100%;
            }

            .stats-grid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
                margin-bottom: 15px;
            }

            .stat-card {
                background: rgba(0, 0, 0, 0.4);
                border-radius: 8px;
                padding: 12px;
                border: 1px solid rgba(59, 130, 246, 0.2);
                transition: all 0.3s ease;
            }

            .stat-card:hover {
                border-color: rgba(59, 130, 246, 0.5);
                transform: translateY(-2px);
            }

            .stat-label {
                font-size: 12px;
                color: #94a3b8;
                margin-bottom: 8px;
                text-transform: uppercase;
                font-weight: 500;
            }

            .stat-value {
                font-size: 18px;
                font-weight: bold;
                color: #3b82f6;
            }

            .positive {
                color: #10b981;
            }

            .negative {
                color: #ef4444;
            }

            .market-status {
                background: rgba(16, 185, 129, 0.2);
                border: 1px solid #10b981;
                border-radius: 8px;
                padding: 12px;
                margin-bottom: 20px;
                text-align: center;
                font-weight: 600;
                color: #10b981;
            }

            .technical-info {
                background: rgba(0, 0, 0, 0.4);
                border-radius: 10px;
                padding: 12px;
                margin-top: 12px;
                flex-shrink: 0;
            }

            .technical-info h3 {
                margin-top: 0;
                margin-bottom: 8px;
                color: #3b82f6;
                font-size: 14px;
            }

            .technical-row {
                display: flex;
                justify-content: space-between;
                margin: 8px 0;
                font-size: 14px;
            }

            .technical-label {
                color: #94a3b8;
            }

            .technical-value {
                color: #ffffff;
                font-weight: 500;
            }

            @media (max-width: 768px) {
                .dashboard-container {
                    grid-template-columns: 1fr;
                    grid-template-rows: auto 1fr;
                    padding: 10px;
                    gap: 10px;
                }

                .sidebar {
                    order: 2;
                    max-height: 40vh;
                    overflow-y: auto;
                }

                .main-content {
                    order: 1;
                }

                .stats-grid {
                    grid-template-columns: repeat(2, 1fr);
                    gap: 8px;
                }

                .controls {
                    flex-direction: column;
                    align-items: stretch;
                    gap: 10px;
                }

                .controls-left {
                    flex-direction: column;
                    gap: 10px;
                }

                .timeframe-buttons {
                    display: flex;
                    gap: 8px;
                    flex-wrap: wrap;
                }

                .timeframe-btn,
                .zoom-btn {
                    min-height: 44px;
                    min-width: 44px;
                    font-size: 12px;
                    padding: 8px 12px;
                }

                .dashboard-title {
                    font-size: 18px;
                    min-width: auto;
                    align-items: center;
                    text-align: center;
                }

                .title-stats-inline {
                    flex-direction: column;
                    gap: 4px;
                }

                .index-dropdown,
                .date-input {
                    min-height: 44px;
                    width: 100%;
                }

                .chart-overlay-controls {
                    top: 10px;
                    left: 10px;
                    right: 10px;
                    transform: none;
                    justify-content: center;
                }
            }

            @media (max-width: 480px) {
                .dashboard-container {
                    padding: 5px;
                }

                .sidebar {
                    padding: 15px;
                }

                .stats-grid {
                    grid-template-columns: 1fr;
                }

                .timeframe-btn {
                    flex: 1;
                    min-width: 60px;
                }

                .dashboard-title {
                    font-size: 16px;
                }

                .title-stats-inline {
                    font-size: 12px;
                }
            }

            .secondary-chart-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 10px 12px;
                font-weight: bold;
                font-size: 16px;
                background-color: rgba(255, 255, 255, 0.05);
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                border-top-left-radius: 8px;
                border-top-right-radius: 8px;
            }

            .chart-overlay-controls {
                display: flex;
                gap: 8px;
                background: rgba(0, 0, 0, 0.6);
                padding: 6px 10px;
                border-radius: 6px;
                border: 1px solid rgba(59, 130, 246, 0.3);
                backdrop-filter: blur(8px);
            }
            /* Secondary Data Popup Styles */
            .secondary-data-popup {
                position: fixed;
                top: 10px;
                left: 20px;
                width: 50vw;
                height: calc(100vh - 20px);
                background: rgba(15, 23, 42, 0.98);
                border: 2px solid #3b82f6;
                border-radius: 8px;
                padding: 0;
                z-index: 9999;
                backdrop-filter: blur(15px);
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
                overflow-y: auto;
                display: none;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                animation: slideInLeft 0.3s ease-out;
                cursor: pointer; /* Make it clear it's clickable */
                user-select: none; /* Prevent text selection on double-click */
                transition: all 0.2s ease; /* Smooth transitions */
            }

            /* Fixed panel mode for Chart-3 zoom mode */
            .secondary-data-popup.fixed-panel {
                position: absolute;
                top: 0;
                left: 0;
                width: 50%;
                height: 100%;
                z-index: 100;
                border-radius: 0;
                border: none;
                border-right: 2px solid #3b82f6;
                background: rgba(15, 23, 42, 0.98);
                backdrop-filter: blur(10px);
                overflow-y: auto;
                transition: none;
                box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
                display: flex;
                flex-direction: column;
            }

            /* Fixed panel header styling */
            .secondary-data-popup.fixed-panel .popup-header {
                background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(59, 130, 246, 0.05));
                border-bottom: 1px solid #3b82f6;
                padding: 12px 16px;
                border-radius: 0;
                flex-shrink: 0;
                position: sticky;
                top: 0;
                z-index: 101;
            }

            /* Fixed panel content styling */
            .secondary-data-popup.fixed-panel .popup-content {
                padding: 16px;
                flex: 1;
                overflow-y: auto;
                scrollbar-width: thin;
                scrollbar-color: #3b82f6 transparent;
            }

            /* Custom scrollbar for fixed panel */
            .secondary-data-popup.fixed-panel .popup-content::-webkit-scrollbar {
                width: 6px;
            }

            .secondary-data-popup.fixed-panel .popup-content::-webkit-scrollbar-track {
                background: transparent;
            }

            .secondary-data-popup.fixed-panel .popup-content::-webkit-scrollbar-thumb {
                background-color: #3b82f6;
                border-radius: 3px;
            }

            /* Zoom mode specific styles for popup (legacy - kept for compatibility) */
            .secondary-data-popup.zoom-mode {
                position: absolute;
                top: 10px;
                left: 10px;
                width: calc(50% - 20px);
                height: calc(100% - 20px);
                z-index: 1000;
            }

            /* Ensure the chart container has relative positioning for zoom mode */
            .secondary-chart.full-size {
                position: relative;
            }

            /* Adjust chart content when fixed panel is active in zoom mode */
            .secondary-chart.full-size.fixed-panel-active .secondary-chart-content {
                width: 50% !important;
                margin-left: 50% !important;
            }

            /* Adjust chart content when popup is active in zoom mode (legacy) */
            .secondary-chart.full-size.popup-active .secondary-chart-content {
                width: calc(50% - 10px) !important;
                margin-left: calc(50% + 10px) !important;
            }

            .secondary-data-popup.show {
                display: block;
            }
            
            .secondary-data-popup.locked {
                border-color: #f59e0b; /* Orange border when locked */
                box-shadow: 0 0 20px rgba(245, 158, 11, 0.3);
            }

            .secondary-data-popup .popup-header {
                background: linear-gradient(135deg, #3b82f6, #1d4ed8);
                padding: 12px 16px;
                border-radius: 6px 6px 0 0;
                color: white;
                font-weight: bold;
                font-size: 14px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .secondary-data-popup .popup-close {
                background: none;
                border: none;
                color: white;
                font-size: 18px;
                cursor: pointer;
                padding: 0;
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 4px;
                transition: background-color 0.2s;
            }

            .secondary-data-popup .popup-close:hover {
                background-color: rgba(255, 255, 255, 0.2);
            }

            .popup-content {
                padding: 16px;
            }

            /* Signal Confidence Section */
            .signal-confidence {
                text-align: center;
                margin-bottom: 20px;
                padding: 12px;
                background: rgba(30, 41, 59, 0.5);
                border-radius: 6px;
                border: 1px solid #475569;
            }

            .signal-confidence h3 {
                margin: 0 0 8px 0;
                color: #3b82f6;
                font-size: 14px;
                font-weight: bold;
            }

            .confidence-bar {
                width: 100%;
                height: 24px;
                background: rgba(30, 41, 59, 0.8);
                border-radius: 12px;
                overflow: hidden;
                position: relative;
                border: 1px solid #475569;
            }

            .confidence-fill {
                height: 100%;
                background: linear-gradient(90deg, #10b981, #34d399);
                border-radius: 12px;
                transition: width 0.5s ease;
                position: relative;
            }

            .confidence-text {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: white;
                font-weight: bold;
                font-size: 12px;
                text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            }

            /* Sentiment Graphs Section */
            .sentiment-section {
                margin-bottom: 20px;
            }

            .sentiment-title {
                color: #94a3b8;
                font-size: 13px;
                font-weight: bold;
                margin-bottom: 12px;
                padding-bottom: 4px;
                border-bottom: 1px solid #475569;
            }

            .sentiment-graphs {
                display: flex;
                gap: 16px;
            }

            .sentiment-graph {
                flex: 1;
                background: rgba(30, 41, 59, 0.3);
                border-radius: 6px;
                padding: 12px;
                border: 1px solid #475569;
                max-height: 600px;
                overflow-y: auto;
            }

            .graph-title {
                color: #94a3b8;
                font-size: 11px;
                font-weight: bold;
                margin-bottom: 8px;
                text-align: center;
            }

            .bar-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
                font-size: 11px;
            }

            .bar-item:last-child {
                margin-bottom: 0;
            }

            .bar-label {
                width: 100px;
                color: #94a3b8;
                font-size: 10px;
                text-align: right;
                margin-right: 12px;
                flex-shrink: 0;
                word-wrap: break-word;
            }

            /* Differentiate Call and Put strikes with subtle colors */
            .bar-label.call-strike {
                color: #8892b0; /* Muted slate blue for Calls */
            }

            .bar-label.put-strike {
                color: #b09688; /* Muted rosewood for Puts */
            }

            .bar-container {
                flex: 1;
                height: 20px;
                background: rgba(30, 41, 59, 0.8);
                border-radius: 10px;
                overflow: visible;
                position: relative;
                border: 1px solid #374151;
                display: flex;
                align-items: center;
            }

            /* Zero line in the center */
            .bar-container::before {
                content: '';
                position: absolute;
                left: 50%;
                top: 0;
                bottom: 0;
                width: 1px;
                background: #64748b;
                z-index: 2;
            }

            .bar-fill {
                height: 100%;
                border-radius: 6px;
                transition: width 0.4s ease;
                position: absolute;
                top: 0;
            }

            /* Positive bars extend to the right from center */
            .bar-fill.positive {
                background: linear-gradient(90deg, #10b981, #34d399);
                left: 50%;
                transform-origin: left;
            }

            /* Negative bars extend to the left from center */
            .bar-fill.negative {
                background: linear-gradient(90deg, #ef4444, #f87171);
                right: 50%;
                transform-origin: right;
            }

            .bar-value {
                position: absolute;
                top: 50%;
                transform: translateY(-50%);
                color: white;
                font-size: 10px;
                font-weight: bold;
                text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
                z-index: 3;
                pointer-events: none;
            }

            /* Position value text based on bar direction */
            .bar-fill.positive + .bar-value {
                left: calc(50% + 4px);
            }

            .bar-fill.negative + .bar-value {
                right: calc(50% + 4px);
            }

            /* Top Section Grid Layout */
            .top-section {
                display: grid;
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto;
                gap: 16px;
                margin-bottom: 16px;
            }

            /* Remove old top-row layout */
            .top-row {
                display: none;
            }

            /* Recommendation Section - Grid position: column 1, row 1 */
            .recommendation-section {
                background: rgba(30, 41, 59, 0.5);
                border-radius: 6px;
                padding: 12px;
                border: 1px solid #475569;
                min-width: 150px;
                grid-column: 1;
                grid-row: 1;
            }

            .recommendation-title {
                color: #e2e8f0;
                font-size: 13px;
                font-weight: bold;
                margin-bottom: 8px;
            }

            .recommendation-content {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .recommendation-display {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                background: rgba(59, 130, 246, 0.1);
                padding: 8px 12px;
                border-radius: 6px;
                border: 1px solid #3b82f6;
            }

            .recommendation-text {
                color: #e2e8f0;
                font-size: 14px;
                font-weight: bold;
            }

            .recommendation-arrow {
                font-size: 18px;
                font-weight: bold;
                color: #e2e8f0;
            }

            .recommendation-arrow.put-arrow {
                color: #e2e8f0;
            }

            .recommendation-arrow.call-arrow {
                color: #e2e8f0;
            }

            .recommendation-note {
                color: #94a3b8;
                font-size: 10px;
                text-align: center;
            }

            /* Signal Confidence - Grid position: column 1, row 2 */
            .signal-confidence {
                background: rgba(30, 41, 59, 0.5);
                border-radius: 6px;
                padding: 12px;
                border: 1px solid #475569;
                text-align: center;
                grid-column: 1;
                grid-row: 2;
            }

            .signal-confidence h3 {
                margin: 0 0 8px 0;
                color: #3b82f6;
                font-size: 14px;
                font-weight: bold;
            }

            /* Second Row Layout */
            .second-row {
                display: flex;
                gap: 16px;
                margin-bottom: 16px;
            }

            /* Sentiment Values Section - 20% width (reduced from 30%) */
            .sentiment-values-section {
                background: rgba(30, 41, 59, 0.5);
                border-radius: 6px;
                padding: 12px;
                border: 1px solid #475569;
                width: 20%;
                min-width: 150px;
            }

            /* TRN_OI Trend Bar Section - Grid position: column 2, spans rows 1-2 */
            .trend-bar-section {
                background: rgba(30, 41, 59, 0.5);
                border-radius: 6px;
                padding: 16px;
                border: 1px solid #475569;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-start;
                grid-column: 2;
                grid-row: 1 / 3;
                min-height: 200px;
            }

            .trend-bar-title {
                color: #94a3b8;
                font-size: 11px;
                font-weight: bold;
                margin-bottom: 8px;
                text-align: center;
                writing-mode: horizontal-tb;
            }

            .trend-bar-container {
                width: 24px;
                height: 150px;
                background: linear-gradient(to bottom, 
                    #2563eb 0%,    /* Solid blue extension area above 100% (top 1/3) */
                    #3b82f6 33.33%, /* Solid blue extension boundary */
                    #3b82f6 33.33%, /* Solid blue 100% marker (green) at 1/3 */
                    #3b82f6 66.67%, /* Solid blue mid range */
                    #3b82f6 100%);  /* Solid blue 0% marker (red) at bottom */
                border-radius: 12px;
                border: 2px solid #1e293b;
                position: relative;
                margin-bottom: 8px;
                box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            }

            /* Add boundary line to separate extension from core range */
            .trend-bar-container::before {
                content: '';
                position: absolute;
                left: -2px;
                right: -2px;
                top: 33.33%;
                height: 1px;
                background: rgba(16, 185, 129, 0.3);
                z-index: 1;
            }

            /* Range markers - positioned for extended bar */
            .range-marker {
                position: absolute;
                left: 100%;
                width: 0;
                z-index: 3;
            }

            .range-marker-100 .marker-time-left {
                position: absolute;
                right: calc(100% + 32px);  /* Position to left of entire bar with gap */
                margin-top: -8px;
                color: #10b981;
                font-size: 12px;  /* Bigger font */
                font-weight: bold;
                white-space: nowrap;
                text-shadow: 0 0 4px rgba(16, 185, 129, 0.6);
            }

            .range-marker-100 .marker-line {
                width: 12px;
                height: 3px;
                background: #10b981;
                margin-left: 2px;
                box-shadow: 0 0 6px rgba(16, 185, 129, 0.6);
            }

            .range-marker-100 .marker-label {
                color: #10b981;
                font-size: 11px;
                font-weight: bold;
                margin-left: 16px;
                margin-top: -7px;
                text-shadow: 0 0 4px rgba(16, 185, 129, 0.8);
            }

            .range-marker-0 .marker-time-left {
                position: absolute;
                right: calc(100% + 32px);  /* Position to left of entire bar with gap */
                margin-top: -8px;
                color: #ef4444;
                font-size: 12px;  /* Bigger font */
                font-weight: bold;
                white-space: nowrap;
                text-shadow: 0 0 4px rgba(239, 68, 68, 0.6);
            }

            .range-marker-0 .marker-line {
                width: 12px;
                height: 3px;
                background: #ef4444;
                margin-left: 2px;
                margin-top: -1px;
                box-shadow: 0 0 6px rgba(239, 68, 68, 0.6);
            }

            .range-marker-0 .marker-label {
                color: #ef4444;
                font-size: 11px;
                font-weight: bold;
                margin-left: 16px;
                margin-top: -8px;
                text-shadow: 0 0 4px rgba(239, 68, 68, 0.8);
            }

            .range-marker-bottom .marker-line-bottom {
                width: 12px;
                height: 3px;
                background: #fbbf24;
                margin-left: 2px;
                margin-top: -1px;
                box-shadow: 0 0 6px rgba(251, 191, 36, 0.6);
            }

            .range-marker-bottom .marker-label-bottom {
                color: #fbbf24;
                font-size: 11px;
                font-weight: bold;
                margin-left: 16px;
                margin-top: -8px;
                text-shadow: 0 0 4px rgba(251, 191, 36, 0.8);
            }

            .range-marker-current .marker-line-current {
                width: 16px;
                height: 3px;
                background: #fbbf24;
                margin-left: 2px;
                margin-top: -1px;
                box-shadow: 0 0 8px rgba(251, 191, 36, 0.8);
            }

            .range-marker-current .marker-label-current {
                color: #fbbf24;
                font-size: 12px;
                font-weight: bold;
                margin-left: 20px;
                margin-top: -9px;
                text-shadow: 0 0 6px rgba(251, 191, 36, 1);
                background: rgba(0, 0, 0, 0.8);
                padding: 2px 6px;
                border-radius: 4px;
                border: 1px solid #fbbf24;
                white-space: nowrap;
                min-width: 35px;
                text-align: center;
            }

            .trend-bar-indicator {
                position: absolute;
                width: calc(100% + 8px);
                height: 6px;
                background: linear-gradient(90deg, #fbbf24 0%, #f59e0b 50%, #d97706 100%);
                border: 2px solid #111827;
                border-radius: 4px;
                left: -4px;
                transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                box-shadow: 0 2px 8px rgba(251, 191, 36, 0.4);
                z-index: 2;
            }

            .trend-bar-indicator:hover {
                box-shadow: 0 4px 12px rgba(251, 191, 36, 0.6);
                transform: scale(1.1);
            }

            .trend-bar-indicator {
                position: absolute;
                width: calc(100% + 8px);
                height: 6px;
                background: linear-gradient(90deg, #fbbf24 0%, #f59e0b 50%, #d97706 100%);
                border: 2px solid #111827;
                border-radius: 4px;
                left: -4px;
                transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                box-shadow: 0 2px 8px rgba(251, 191, 36, 0.4);
                z-index: 2;
            }

            .trend-bar-indicator:hover {
                box-shadow: 0 4px 12px rgba(251, 191, 36, 0.6);
                transform: scale(1.1);
            }

            .trend-bar-indicator::before {
                content: '';
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                width: 3px;
                height: 3px;
                background: #fef3c7;
                border-radius: 50%;
            }

            .trend-bar-value {
                color: #e2e8f0;
                font-size: 12px;
                font-weight: bold;
                text-align: center;
                margin-bottom: 12px;
            }

            /* Time Information Display */
            .trend-time-info {
                margin-top: 16px;
                width: 100%;
            }

            .time-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 6px 12px;
                margin-bottom: 6px;
                background: rgba(15, 23, 42, 0.5);
                border-radius: 4px;
                border: 1px solid #334155;
            }

            .time-label {
                color: #94a3b8;
                font-size: 11px;
                font-weight: 500;
            }

            .time-value {
                color: #f59e0b;
                font-size: 12px;
                font-weight: bold;
                font-family: 'Courier New', monospace;
            }

            .sentiment-title {
                color: #94a3b8;
                font-size: 13px;
                font-weight: bold;
                margin-bottom: 8px;
            }

            .sentiment-displays {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .sentiment-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 6px 8px;
                background: rgba(15, 23, 42, 0.5);
                border-radius: 4px;
                border: 1px solid #334155;
            }

            .sentiment-label {
                color: #94a3b8;
                font-size: 11px;
                font-weight: 500;
            }

            .sentiment-value {
                font-size: 12px;
                font-weight: bold;
            }

            .sentiment-value.positive {
                color: #10b981;
            }

            .sentiment-value.negative {
                color: #ef4444;
            }

            /* Compact Instruments Section - 80% width (increased from 60%) */
            .instruments-section-compact {
                background: rgba(30, 41, 59, 0.5);
                border-radius: 6px;
                padding: 12px;
                border: 1px solid #475569;
                width: 80%;
            }

            /* Sentiment Graph Subtitles */
            .sentiment-subtitle {
                color: #94a3b8; /* Neutral color */
                font-size: 11px;
                font-weight: bold;
                margin-bottom: 8px;
                text-align: center;
            }
            
            /* Colored values within sentiment subtitles */
            .sentiment-subtitle .positive {
                color: #10b981; /* Green for positive values */
            }
            
            .sentiment-subtitle .negative {
                color: #ef4444; /* Red for negative values */
            }

            /* Instruments Section */
            .instruments-section {
                background: rgba(30, 41, 59, 0.5);
                border-radius: 6px;
                padding: 12px;
                border: 1px solid #475569;
                margin-bottom: 16px;
            }

            .instruments-title {
                color: #e2e8f0;
                font-size: 13px;
                font-weight: bold;
                margin-bottom: 8px;
            }

            .instruments-table {
                width: 100%;
            }

            .instruments-header {
                display: grid;
                grid-template-columns: 1fr 1fr 1fr 1fr;
                gap: 8px;
                padding: 8px 0;
                border-bottom: 1px solid #475569;
                margin-bottom: 8px;
            }

            .instruments-row {
                display: grid;
                grid-template-columns: 1fr 1fr 1fr 1fr;
                gap: 8px;
                padding: 6px 0;
                border-bottom: 1px solid rgba(71, 85, 105, 0.3);
            }

            .instruments-row:last-child {
                border-bottom: none;
            }

            .instr-col {
                color: #e2e8f0;
                font-size: 11px;
                text-align: center;
            }

            .instruments-header .instr-col {
                color: #94a3b8;
                font-weight: bold;
                font-size: 10px;
            }

            /* Summary Stats */
            .summary-stats {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
                margin-bottom: 16px;
            }

            .stat-item {
                background: rgba(30, 41, 59, 0.5);
                border-radius: 4px;
                padding: 8px;
                border: 1px solid #475569;
                text-align: center;
            }

            .stat-label {
                color: #94a3b8;
                font-size: 10px;
                margin-bottom: 2px;
            }

            .stat-value {
                color: #e2e8f0;
                font-size: 12px;
                font-weight: bold;
            }

            .no-data {
                text-align: center;
                color: #94a3b8;
                font-style: italic;
                padding: 20px;
            }

            @keyframes slideInLeft {
                from {
                    transform: translateX(-100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }

            @keyframes slideOutLeft {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(-100%);
                    opacity: 0;
                }
            }

            @keyframes slideInRight {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }

            @keyframes slideOutRight {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(100%);
                    opacity: 0;
                }
            }

            .secondary-data-popup.hiding {
                animation: slideOutLeft 0.3s ease-in forwards;
            }

        </style>
    </head>

    <body>
        <div class="dashboard-container">
            <div class="sidebar">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Important Candles</div>
                        <div class="stat-value" id="important-candles">--</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">High Volume Candles</div>
                        <div class="stat-value" id="high-volume-candles">--</div>
                    </div>
                </div>

                <div class="technical-info">
                    <div class="collapsible-header" onclick="toggleSection('important-candles')" style="cursor: pointer; display: flex; align-items: center; justify-content: space-between; padding: 4px 0;">
                        <h3 style="margin: 0; display: flex; align-items: center;">
                            <span id="important-candles-icon" style="margin-right: 8px; font-size: 12px;">−</span>
                            🎯 Important Candles
                            <span id="important-candles-count" style="margin-left: 8px; font-size: 11px; color: #6b7280;"></span>
                        </h3>
                    </div>
                    <div id="important-candles-content" style="max-height: 200px; overflow-y: auto;">
                        <div id="important-candles-list">
                            <div style="color: #6b7280; font-size: 12px; text-align: center; padding: 10px;">
                                Loading...
                            </div>
                        </div>
                    </div>
                </div>

                <div class="technical-info">
                    <div class="collapsible-header" onclick="toggleSection('high-volume-candles')" style="cursor: pointer; display: flex; align-items: center; justify-content: space-between; padding: 4px 0;">
                        <h3 style="margin: 0; display: flex; align-items: center; font-size: 13px;">
                            <span id="high-volume-candles-icon" style="margin-right: 8px; font-size: 12px;">−</span>
                            📈 High Volume Candles
                            <span id="high-volume-candles-count" style="margin-left: 8px; font-size: 11px; color: #6b7280;"></span>
                        </h3>
                    </div>
                    <div id="high-volume-candles-content" style="max-height: 150px; overflow-y: auto; font-size: 10px;">
                        <div id="important-volume-candles-list">
                            <div style="color: #6b7280; font-size: 12px; text-align: center; padding: 10px;">
                                Loading...
                            </div>
                        </div>
                    </div>
                </div>

                <div class="technical-info">
                    <div class="collapsible-header" onclick="toggleSection('future-oi-changes')" style="cursor: pointer; display: flex; align-items: center; justify-content: space-between; padding: 4px 0;">
                        <h3 style="margin: 0; display: flex; align-items: center; font-size: 13px;">
                            <span id="future-oi-changes-icon" style="margin-right: 8px; font-size: 12px;">−</span>
                            📊 Future OI Changes
                            <span id="future-oi-changes-count" style="margin-left: 8px; font-size: 11px; color: #6b7280;"></span>
                        </h3>
                    </div>
                    <div id="future-oi-changes-content" style="max-height: 150px; overflow-y: auto; font-size: 10px;">
                        <div id="future-oi-changes-list">
                            <div style="color: #6b7280; font-size: 12px; text-align: center; padding: 10px;">
                                Loading...
                            </div>
                        </div>
                    </div>
                </div>

                <div class="technical-info">
                    <h3>📊 Technical Analysis</h3>
                    <div class="technical-row">
                        <span class="technical-label">Support Level:</span>
                        <span class="technical-value" id="support-level">₹--</span>
                    </div>
                    <div class="technical-row">
                        <span class="technical-label">Resistance Level:</span>
                        <span class="technical-value" id="resistance-level">₹--</span>
                    </div>
                    <div class="technical-row">
                        <span class="technical-label">Range:</span>
                        <span class="technical-value" id="price-range">₹--</span>
                    </div>
                    <div class="technical-row">
                        <span class="technical-label">Bullish Candles:</span>
                        <span class="technical-value positive" id="bullish-count">--</span>
                    </div>
                    <div class="technical-row">
                        <span class="technical-label">Bearish Candles:</span>
                        <span class="technical-value negative" id="bearish-count">--</span>
                    </div>
                </div>
            </div>
            <div class="main-content">
                <div class="controls">
                    <div class="controls-left">
                        <div class="index-selector">
                            <label for="index-select">Index:</label>
                            <select id="index-select" class="index-dropdown">
                                <option value="NIFTY" selected>NIFTY 50</option>
                                <option value="BANK NIFTY">BANK NIFTY</option>
                            </select>
                        </div>
                        <div class="timeframe-buttons">
                            <button class="timeframe-btn" data-timeframe="1m">1M</button>
                            <button class="timeframe-btn active" data-timeframe="5m">5M</button>
                            <button class="timeframe-btn" data-timeframe="15m">15M</button>
                            <button class="timeframe-btn" data-timeframe="30m">30M</button>
                            <button class="timeframe-btn" data-timeframe="1h">1H</button>
                        </div>
                        <div class="date-selector">
                            <label for="date-select">Date:</label>
                            <input type="date" id="date-select" class="date-input">
                            <button class="refresh-btn" id="refresh-btn" title="Refresh Data">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="23 4 23 10 17 10"></polyline>
                                    <polyline points="1 20 1 14 7 14"></polyline>
                                    <path d="m20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15">
                                    </path>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="dashboard-title" id="dashboard-title">
                        <div class="title-main">
                            <div class="chart-mode-buttons">
                                <button class="chart-mode-btn active" data-mode="1" title="Main Chart (Double-click any button to show all charts)">1</button>
                                <button class="chart-mode-btn active" data-mode="2" title="OI Analysis Chart (Double-click any button to show all charts)">2</button>
                                <button class="chart-mode-btn active" data-mode="3" title="Sentiment Analysis Chart (Double-click any button to show all charts)">3</button>
                            </div>
                            📈 NIFTY 50 Dashboard
                            <div class="live-indicator"></div>
                        </div>
                        <div class="title-stats-inline">
                            <span class="title-stat">High: <span class="stat-value positive"
                                    id="day-high">₹--</span></span>
                            <span class="title-separator">↔</span>
                            <span class="title-stat">Low: <span class="stat-value negative"
                                    id="day-low">₹--</span></span>
                            <span class="title-separator">::</span>
                            <span class="data-date" id="data-date">--</span>
                        </div>
                    </div>
                </div>

                <div class="charts-container">
                    <div class="chart-container">
                        <div class="secondary-chart-title">
                            <span>📈 Main Chart - Candlestick Analysis</span>
                            <div class="chart-overlay-controls">
                                <button class="zoom-btn" id="zoom-in">🔍+</button>
                                <button class="zoom-btn" id="zoom-out">🔍-</button>
                                <button class="zoom-btn" id="fit-content">📏 Fit</button>
                            </div>
                        </div>
                        <div id="chart"></div>
                    </div>

                    <div class="secondary-charts-container">
                        <div class="secondary-chart">
                            <div class="secondary-chart-title">
                                <span>📈 Trending OI Analysis (1-min)</span>
                                <div class="chart-overlay-controls">
                                    <button class="zoom-btn" id="oi-zoom-in">🔍+</button>
                                    <button class="zoom-btn" id="oi-zoom-out">🔍-</button>
                                    <button class="zoom-btn" id="oi-fit-content">📏 Fit</button>
                                </div>
                            </div>
                            <div class="secondary-chart-content" id="oi-chart"></div>
                        </div>

                        <div class="secondary-chart">
                            <div class="secondary-chart-title">
                                <span id="sentiment-chart-title">📊 Sentiment Analysis (1-min)</span>
                                <div class="chart-overlay-controls">
                                    <button class="zoom-btn" id="sentiment-zoom-in">🔍+</button>
                                    <button class="zoom-btn" id="sentiment-zoom-out">🔍-</button>
                                    <button class="zoom-btn" id="sentiment-fit-content">📏 Fit</button>
                                </div>
                            </div>
                            <div class="secondary-chart-content" id="sentiment-chart"></div>
                        </div>
                    </div>

                </div>
            </div>
        </div>
        <script
            src="https://unpkg.com/lightweight-charts@3.7.0/dist/lightweight-charts.standalone.production.js"></script>

        <script>
            // Early debug logging
            console.log('🚀 Script loading started...');

            // Check if LightweightCharts loads
            window.addEventListener('load', () => {
                console.log('📄 Page loaded');
                console.log('📊 LightweightCharts available:', typeof LightweightCharts !== 'undefined');
            });

            // Log any global errors
            window.addEventListener('error', (e) => {
                console.error('🔥 Global error:', e.error?.message || e.message, e.filename, e.lineno);
            });

            // Log unhandled promise rejections
            window.addEventListener('unhandledrejection', (e) => {
                console.error('🔥 Unhandled promise rejection:', e.reason);
            });
        </script>
        <script>
            // Global popup event listener functions - moved to top for availability
            function initializePopupEventListeners() {
                const popup = document.getElementById('secondary-data-popup');
                if (!popup) {
                    console.error('❌ Popup element not found!');
                    return false;
                }
                
                console.log('🎯 Initializing popup event listeners...');
                console.log('🎯 Popup parent element:', popup.parentElement?.className || 'unknown');
                console.log('🎯 Popup classes:', popup.className);
                
                // Remove any existing listeners first (prevent duplicates)
                popup.removeEventListener('dblclick', handlePopupDoubleClick);
                popup.removeEventListener('contextmenu', handlePopupRightClick);
                popup.removeEventListener('click', handlePopupClick);
                
                // Add event listeners
                popup.addEventListener('dblclick', handlePopupDoubleClick);
                popup.addEventListener('contextmenu', handlePopupRightClick);
                popup.addEventListener('click', handlePopupClick);
                
                console.log('✅ Popup event listeners initialized successfully');
                return true;
            }

            function handlePopupDoubleClick(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const popup = document.getElementById('secondary-data-popup');
                if (popup) {
                    console.log('🔒 Popup locked via double-click');
                    isPopupLocked = true;
                    popup.classList.add('locked');
                }
            }

            function handlePopupRightClick(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const popup = document.getElementById('secondary-data-popup');
                if (popup) {
                    console.log('🔓 Popup unlocked via right-click');
                    isPopupLocked = false;
                    popup.classList.remove('locked');
                }
            }

            function handlePopupClick(e) {
                // Only stop propagation to prevent chart interactions when clicking inside popup
                e.stopPropagation();
            }

            // Global variables for popup functionality (moved here for early availability)
            let secondaryDataPopup = null; // Reference to popup element
            let popupHideTimeout = null; // Timeout for auto-hide
            let isPopupLocked = false; // Track if popup is locked/pinned

            // Helper function to safely parse float values
            function safeParseFloat(value, defaultValue = 0) {
                if (!value || value === '' || value === 'inf' || value === '-inf' || value === 'nan') {
                    return defaultValue;
                }
                const parsed = parseFloat(value);
                if (isNaN(parsed) || !isFinite(parsed)) {
                    return defaultValue;
                }
                return parsed;
            }

            // Helper function to safely call toFixed on a value
            function safeToFixed(value, decimals = 2, defaultValue = '0.00') {
                if (typeof value !== 'number' || isNaN(value) || !isFinite(value)) {
                    return defaultValue.padEnd(decimals + 2, '0');
                }
                return value.toFixed(decimals);
            }

            // Index configuration
            const INDEX_CONFIG = {
                'NIFTY': {
                    filenamePattern: 'NIF_deep_analysis_{{DATE}}.csv',
                    priceDivisor: 50,
                    volumeBaseline: 125000,
                    title: 'NIFTY 50'
                },
                'BANK NIFTY': {
                    filenamePattern: 'BNF_deep_analysis_{{DATE}}.csv',
                    priceDivisor: 100,
                    volumeBaseline: 50000,
                    title: 'BANK NIFTY'
                }
            };

            // Current selections
            let currentIndex = 'NIFTY';
            let currentDate = null; // Will be set by findMostRecentData
            let PRICE_DIVISOR = INDEX_CONFIG[currentIndex].priceDivisor;
            let VOLUME_BASELINE = INDEX_CONFIG[currentIndex].volumeBaseline;
            let IMPORTANT_CANDLE_THRESHOLD = PRICE_DIVISOR * 0.55;

            // Chart mode tracking for 3 separate charts
            let chartModes = {
                '1': true,  // Main candlestick chart - enabled by default
                '2': true,  // OI Analysis chart - enabled by default
                '3': true   // Sentiment Analysis chart - enabled by default
            };

            // Function to check if data exists for a given date
            async function checkDataExists(index, dateString) {
                const filename = generateFilename(index, dateString);
                try {
                    const response = await fetch(filename);
                    return response.ok;
                } catch (error) {
                    return false;
                }
            }

            // Function to find most recent data within last 7 days
            async function findMostRecentData(index) {
                const today = new Date();
                let currentAttempt = new Date(today);

                // Try last 7 days
                for (let i = 0; i < 7; i++) {
                    const dateString = currentAttempt.toISOString().split('T')[0];
                    console.log(`🔍 Checking data for ${dateString}...`);

                    if (await checkDataExists(index, dateString)) {
                        console.log(`✅ Found data for ${dateString}`);
                        return dateString;
                    }

                    // Go back one day
                    currentAttempt.setDate(currentAttempt.getDate() - 1);
                }

                console.error('❌ No data found in last 7 days');
                return null;
            }

            // Get current filename based on index and date
            function getCurrentFilename() {
                return generateFilename(currentIndex, currentDate);
            }

            // Load data for current index and date combination
            async function loadDataForCurrentSelection() {
                const filename = getCurrentFilename();
                console.log(`📁 Loading data for ${currentIndex} on ${currentDate}: ${filename}`);

                // Update the config with current filename
                INDEX_CONFIG[currentIndex].filename = filename;

                try {
                    const data = await loadData();
                    if (data && data.length > 0) {
                        console.log(`📊 Loaded ${data.length} data points for ${currentIndex} on ${currentDate}`);

                        // Clear original data cache to ensure fresh data
                        originalData = data;
                        const aggregatedData = aggregateData(data, currentTimeframe);
                        updateChart(aggregatedData);
                        updateOIChart(); // OI chart always uses 1-minute data
                        updateSentimentChart(); // Always uses 1-minute data
                        updateStats(aggregatedData);
                        console.log(`✅ Successfully loaded ${currentIndex} data for ${currentDate}`);
                        
                        // Preload secondary data for faster hover response
                        if (currentDate) {
                            try {
                                console.log('📊 Preloading secondary data for faster hover response...');
                                loadSecondaryData(currentDate).then(() => {
                                    console.log('✅ Secondary data preloaded successfully');
                                }).catch(error => {
                                    console.warn('⚠️ Could not preload secondary data:', error);
                                });
                            } catch (error) {
                                console.warn('⚠️ Error starting secondary data preload:', error);
                            }
                        }
                        return true;
                    } else {
                        console.error(`❌ No data loaded for ${currentIndex} on ${currentDate}`);
                        alert(`No data found for ${currentIndex} on ${currentDate}. The CSV file might be empty or not exist.`);
                        return false;
                    }
                } catch (error) {
                    console.error(`❌ Error loading data for ${currentIndex} on ${currentDate}:`, error);

                    if (error.message.includes('fetch')) {
                        alert(`File not found: ${filename}\nPlease ensure the file exists for ${currentIndex} on ${currentDate}.`);
                    } else {
                        alert(`Failed to load data for ${currentIndex} on ${currentDate}:\n${error.message}`);
                    }
                    return false;
                }
            }

            // Extract date from filename
            function extractDateFromFilename(filename) {
                // Pattern: PREFIX_deep_analysis_YYYY-MM-DD.csv
                const dateMatch = filename.match(/(\d{4}-\d{2}-\d{2})/);
                if (dateMatch) {
                    const dateStr = dateMatch[1]; // YYYY-MM-DD format
                    const [year, month, day] = dateStr.split('-');

                    // Format as DD-MON-YYYY
                    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    const monthName = months[parseInt(month) - 1];
                    return `${day}-${monthName}-${year}`;
                }
                return null;
            }

            // Generate filename for selected date
            function generateFilename(index, dateString) {
                const config = INDEX_CONFIG[index];
                return config.filenamePattern.replace('{{DATE}}', dateString);
            } let chart;
            let candlestickSeries;
            let oiChart;
            let callOISeries;
            let openInterestSeries;
            let originalData = [];
            let currentTimeframe = '5m';
            let importantCandles = []; // Store important candles
            let highVolumeCandles = []; // Store high volume candles

            // Debug output function - console logging only
            function debugLog(message, isAlert = false) {
                console.log(message);
                // Alerts disabled for smoother debugging
            }
            let futureOIChanges = []; // Store future OI changes

            // Find important candles with dynamic threshold
            function findImportantCandles(data) {
                const important = data.filter(candle => {
                    const range = Math.abs(candle.open - candle.close);
                    return range > IMPORTANT_CANDLE_THRESHOLD;
                });

                console.log(`🎯 Found ${important.length} important candles (range > ${IMPORTANT_CANDLE_THRESHOLD})`);
                return important;
            }

            // Find high volume candles (volume > 1.0x baseline)
            function findHighVolumeCandles(data) {
                const highVolume = data.filter(candle => {
                    const volume = candle.vol_1m || candle.volume || 0; // Use vol_1m preferentially
                    const volMultiple = volume / VOLUME_BASELINE;
                    return volMultiple > 1.0; // Volume is more than 1.0x the baseline
                });

                console.log(`📈 Found ${highVolume.length} high volume candles (>1.0x baseline)`);
                return highVolume;
            }

            // Find Future OI changes with >0.9% change from existing oi_5m_pct_chng column
            function findFutureOIChanges(data) {
                const oiChanges = [];
                
                console.log(`🔍 Checking OI changes in ${data.length} data points using oi_5m_pct_chng column...`);
                
                for (let i = 0; i < data.length; i++) {
                    const current = data[i];
                    
                    // Use the pre-calculated oi_5m_pct_chng column
                    if (current.oi_5m_pct_chng !== undefined && current.oi_5m_pct_chng !== null) {
                        const pctChange = safeParseFloat(current.oi_5m_pct_chng);
                        
                        // Debug logging for specific times
                        if (current.time_str && ['09:30', '09:31', '09:33', '09:34'].includes(current.time_str)) {
                            console.log(`🔍 OI Debug for ${current.time_str}:`, {
                                oi_5m_pct_chng: current.oi_5m_pct_chng,
                                pctChange: safeToFixed(pctChange, 3) + '%',
                                fut_oi: current.fut_oi,
                                meetsThreshold: Math.abs(pctChange) > 0.9 ? 'YES' : 'NO'
                            });
                        }
                        
                        if (Math.abs(pctChange) > 0.9) { // Use 0.9% threshold as requested
                            oiChanges.push({
                                ...current,
                                oiChange: current.fut_oi, // Store current OI value
                                oiChangePct: pctChange
                            });
                        }
                    }
                }

                console.log(`📊 Found ${oiChanges.length} significant OI changes (>0.9%) using oi_5m_pct_chng column`);
                return oiChanges;
            }

            // Calculate weights for a candle
            function calculateWeights(candle) {
                const range = candle.high - candle.low;

                // Avoid division by zero and handle invalid candle data
                if (range === 0 || !isFinite(range) || isNaN(range)) {
                    return { 
                        wgt_price: 0, 
                        wgt_price_vol: 0,
                        range: 0,
                        body: 0,
                        upperWick: 0,
                        lowerWick: 0,
                        upperWkPct: 0,
                        lowerWkPct: 0,
                        bodyPct: 0,
                        volXTimes: 0,
                        direction: 0
                    };
                }

                const body = candle.close - candle.open; // Positive for bullish, negative for bearish
                const upperWick = candle.high - Math.max(candle.open, candle.close);
                const lowerWick = Math.min(candle.open, candle.close) - candle.low;
                const upperWkPct = safeParseFloat((upperWick / range) * 100);
                const lowerWkPct = safeParseFloat((lowerWick / range) * 100);
                const bodyPct = safeParseFloat((Math.abs(body) / range) * 100);
                // Simple volume multiple calculation using configurable baseline
                const volXTimes = safeParseFloat(candle.volume / VOLUME_BASELINE);

                // Direction calculation
                let direction;
                if (upperWkPct > 45) {
                    direction = -1; // Upper wick dominates - bearish
                } else if (lowerWkPct > 45) {
                    direction = 1;  // Lower wick dominates - bullish
                } else {
                    direction = body > 0 ? 1 : -1; // Follow body direction
                }

                // Weight calculations
                const wgtPrice = safeParseFloat(direction * Math.abs((body / PRICE_DIVISOR) * (bodyPct / 100)));
                const wgtPriceVol = safeParseFloat(wgtPrice * volXTimes);

                return {
                    wgt_price: wgtPrice,
                    wgt_price_vol: wgtPriceVol,
                    range: range,
                    body: body,
                    upperWick: upperWick,
                    lowerWick: lowerWick,
                    upperWkPct: upperWkPct,
                    lowerWkPct: lowerWkPct,
                    bodyPct: bodyPct,
                    volXTimes: volXTimes,
                    direction: direction
                };
            }

            // Initialize chart
            function initializeChart() {
                console.log('🔧 Initializing chart...');
                const chartContainer = document.getElementById('chart');

                if (!chartContainer) {
                    console.error('❌ Chart container not found!');
                    return;
                }

                console.log('📐 Chart container dimensions:', chartContainer.clientWidth, 'x', chartContainer.clientHeight);

                if (chartContainer.clientWidth === 0 || chartContainer.clientHeight === 0) {
                    console.warn('⚠️ Chart container has zero dimensions, waiting...');
                    setTimeout(() => {
                        console.log('🔄 Retrying chart initialization...');
                        initializeChart();
                    }, 100);
                    return;
                }

                chart = LightweightCharts.createChart(chartContainer, {
                    width: chartContainer.clientWidth,
                    height: chartContainer.clientHeight,
                    layout: {
                        backgroundColor: 'transparent',
                        textColor: '#ffffff',
                    },
                    grid: {
                        vertLines: { color: 'rgba(59, 130, 246, 0.1)' },
                        horzLines: { color: 'rgba(59, 130, 246, 0.1)' },
                    },
                    crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                    rightPriceScale: {
                        borderColor: 'rgba(59, 130, 246, 0.3)',
                        textColor: '#ffffff',
                    }, timeScale: {
                        borderColor: 'rgba(59, 130, 246, 0.3)',
                        textColor: '#ffffff',
                        timeVisible: true,
                        secondsVisible: false,
                        tickMarkFormatter: (time) => {
                            const date = new Date(time * 1000);
                            return date.toLocaleTimeString('en-GB', {
                                hour: '2-digit',
                                minute: '2-digit',
                                hour12: false,
                                timeZone: 'Asia/Kolkata'
                            });
                        },
                    },
                    localization: {
                        timeFormatter: (time) => {
                            const date = new Date(time * 1000);
                            return date.toLocaleString('en-GB', {
                                hour12: false,
                                timeZone: 'Asia/Kolkata'
                            });
                        }
                    },
                    handleScroll: {
                        mouseWheel: true,
                        pressedMouseMove: true,
                        horzTouchDrag: true,
                        vertTouchDrag: true,
                    }, handleScale: {
                        axisPressedMouseMove: true,
                        mouseWheel: true,
                        pinch: true
                    }
                });

                console.log('📊 Chart created successfully');
                
                // Make chart globally accessible for resize function
                window.chart = chart;

                // Regular volume candlestick series
                candlestickSeries = chart.addCandlestickSeries({
                    upColor: '#16a085',      // Teal green for regular bullish candles
                    downColor: '#e74c3c',    // Red for regular bearish candles
                    borderUpColor: '#16a085',
                    borderDownColor: '#e74c3c',
                    wickUpColor: '#16a085',
                    wickDownColor: '#e74c3c'
                });            // High volume candlestick series (more impactful colors)
                window.highVolumeSeries = chart.addCandlestickSeries({
                    upColor: '#00ff41',      // Electric neon green for bullish high volume
                    downColor: '#ff0080',    // Electric magenta for bearish high volume (more impactful)
                    borderUpColor: '#00ff41',
                    borderDownColor: '#ff0080',
                    wickUpColor: '#00ff41',
                    wickDownColor: '#ff0080'
                });

                // Add custom tooltip
                const tooltip = document.createElement('div');
                tooltip.style.cssText = `
                position: absolute;
                background: rgba(0, 0, 0, 0.9);
                color: #ffffff;
                padding: 10px;
                border-radius: 8px;
                border: 1px solid rgba(59, 130, 246, 0.5);
                font-size: 12px;
                font-family: monospace;
                pointer-events: none;
                z-index: 1000;
                display: none;
                backdrop-filter: blur(10px);
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            `;
                chartContainer.appendChild(tooltip);            // Subscribe to crosshair move for tooltip
                chart.subscribeCrosshairMove((param) => {
                    if (!param.point || !param.time) {
                        tooltip.style.display = 'none';
                        return;
                    }

                    // Check both regular and high-volume series for data
                    const regularData = param.seriesPrices.get(candlestickSeries);
                    const highVolumeData = param.seriesPrices.get(window.highVolumeSeries);
                    const data = regularData || highVolumeData;

                    if (!data) {
                        tooltip.style.display = 'none';
                        return;
                    }

                    // Find the volume data for this time point
                    const timePoint = param.time;
                    let volumeData = null;

                    // Get current aggregated data
                    const currentData = aggregateData(originalData, currentTimeframe);
                    volumeData = currentData.find(d => d.time === timePoint);

                    // If not found, find the closest time point
                    if (!volumeData && currentData.length > 0) {
                        volumeData = currentData.reduce((closest, current) => {
                            return Math.abs(current.time - timePoint) < Math.abs(closest.time - timePoint) ? current : closest;
                        });
                    } if (!volumeData) {
                        tooltip.style.display = 'none';
                        return;
                    }                // Calculate weights for the current candle
                    const weights = calculateWeights(volumeData);
                    const bodyColor = weights.body >= 0 ? '#10b981' : '#ef4444';
                    const wgtPriceColor = weights.wgt_price >= 0 ? '#10b981' : '#ef4444';
                    const wgtPriceVolColor = weights.wgt_price_vol >= 0 ? '#10b981' : '#ef4444';
                    const volXTimesColor = weights.volXTimes > 1 ? '#ffffff' : '#b0b0b0'; // Bright white if > 1, light white if < 1

                    // Find high and low times for this timeframe period
                    let highTime = '';
                    let lowTime = '';
                    let impCandlesText = ''; if (currentTimeframe === '1m') {
                        // For 1-minute, high and low time is the same as current time
                        const currentDate = new Date(timePoint * 1000);
                        const timeStr = currentDate.toLocaleTimeString('en-GB', {
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: false,
                            timeZone: 'Asia/Kolkata'
                        });
                        highTime = timeStr;
                        lowTime = timeStr;                    // Check if this is an important candle
                        const range = Math.abs(volumeData.open - volumeData.close);
                        if (range > IMPORTANT_CANDLE_THRESHOLD) {
                            const rangeValue = volumeData.close - volumeData.open;
                            const rangeColor = rangeValue >= 0 ? '#10b981' : '#ef4444';
                            impCandlesText = `<div style="color: #94a3b8;">Imp-candles:</div><div style="color: ${rangeColor}; font-weight: bold;">${timeStr} [${safeToFixed(rangeValue, 2)}]</div>`;
                        } else {
                            impCandlesText = `<div style="color: #94a3b8;">Imp-candles:</div><div style="color: #6b7280;">None</div>`;
                        }
                    } else {
                        // For aggregated timeframes, find the actual times of high and low within the period
                        const minutes = { '5m': 5, '15m': 15, '30m': 30, '1h': 60 }[currentTimeframe];
                        const startTime = timePoint;
                        const endTime = startTime + (minutes * 60);

                        // Find 1-minute candles within this timeframe
                        const periodCandles = originalData.filter(d => d.time >= startTime && d.time < endTime);

                        if (periodCandles.length > 0) {
                            const highCandle = periodCandles.find(d => d.high === volumeData.high);
                            const lowCandle = periodCandles.find(d => d.low === volumeData.low);
                            if (highCandle) {
                                const highDate = new Date(highCandle.time * 1000);
                                highTime = highDate.toLocaleTimeString('en-GB', {
                                    hour: '2-digit',
                                    minute: '2-digit',
                                    hour12: false,
                                    timeZone: 'Asia/Kolkata'
                                });
                            }

                            if (lowCandle) {
                                const lowDate = new Date(lowCandle.time * 1000);
                                lowTime = lowDate.toLocaleTimeString('en-GB', {
                                    hour: '2-digit',
                                    minute: '2-digit',
                                    hour12: false,
                                    timeZone: 'Asia/Kolkata'
                                });
                            }                        // Find important candles in this period
                            const importantInPeriod = periodCandles.filter(candle => {
                                const range = Math.abs(candle.open - candle.close);
                                return range > IMPORTANT_CANDLE_THRESHOLD;
                            }); if (importantInPeriod.length > 0) {
                                const impCandlesList = importantInPeriod.map(candle => {
                                    const candleDate = new Date(candle.time * 1000);
                                    const candleTimeStr = candleDate.toLocaleTimeString('en-GB', {
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        hour12: false,
                                        timeZone: 'Asia/Kolkata'
                                    });
                                    const rangeValue = candle.close - candle.open;
                                    const rangeColor = rangeValue >= 0 ? '#10b981' : '#ef4444';
                                    return `<span style="color: ${rangeColor}; font-weight: bold;">${candleTimeStr} [${safeToFixed(rangeValue, 2)}]</span>`;
                                }).join('<br>');
                                impCandlesText = `<div style="color: #94a3b8;">Imp-candles:</div><div>${impCandlesList}</div>`;
                            } else {
                                impCandlesText = `<div style="color: #94a3b8;">Imp-candles:</div><div style="color: #6b7280;">None</div>`;
                            }
                        }
                    }

                    tooltip.innerHTML = `
                    <div style="display: grid; grid-template-columns: 90px 1fr; gap: 8px; font-size: 12px;">
                        <div style="color: #94a3b8;">HIGH:</div><div style="color: #10b981; font-weight: bold;">${highTime}</div>
                        <div style="color: #94a3b8;">LOW:</div><div style="color: #ef4444; font-weight: bold;">${lowTime}</div>

                        <div style="color: #94a3b8;">Volume:</div><div style="color: #fbbf24; font-weight: bold;">${(volumeData.volume || 0).toLocaleString('en-IN')}</div>
                        ${impCandlesText}                        <div style="color: #94a3b8;">Body:</div><div style="color: ${bodyColor}; font-weight: bold;">${safeToFixed(weights.body, 2)}</div>
                        <div style="color: #94a3b8;">Vol_x_times:</div><div style="color: ${volXTimesColor};"> [${safeToFixed(weights.volXTimes, 2)} X] </div>
                        <div style="color: #94a3b8;">Wgt_price:</div><div style="color: ${wgtPriceColor}; font-weight: bold;">${safeToFixed(weights.wgt_price, 3)}</div>
                        <div style="color: #94a3b8;">Wgt_price_vol:</div><div style="color: ${wgtPriceVolColor}; font-weight: bold;">${safeToFixed(weights.wgt_price_vol, 3)}</div>
                    </div>
                `;

                    const rect = chartContainer.getBoundingClientRect();
                    tooltip.style.left = Math.min(param.point.x + 15, rect.width - tooltip.offsetWidth - 10) + 'px';
                    tooltip.style.top = Math.max(param.point.y - tooltip.offsetHeight - 10, 10) + 'px';
                    tooltip.style.display = 'block';
                });

                // Handle resize
                window.addEventListener('resize', () => {
                    chart.applyOptions({ width: chartContainer.clientWidth });
                });
            }
            // Initialize OI Chart
            function initializeOIChart() {
                console.log('🔧 Initializing OI chart...');
                console.log('🔍 Checking for oi-chart container...');

                const oiChartContainer = document.getElementById('oi-chart');

                if (!oiChartContainer) {
                    console.error('❌ OI Chart container not found!');
                    return;
                }

                console.log('✅ OI Chart container found:', oiChartContainer);
                console.log('📏 Container dimensions:', {
                    width: oiChartContainer.clientWidth,
                    height: oiChartContainer.clientHeight
                });

                // Check dimensions and retry if needed
                if (oiChartContainer.clientWidth === 0 || oiChartContainer.clientHeight === 0) {
                    console.warn('⚠️ OI Chart container has zero dimensions, retrying...');
                    setTimeout(() => {
                        initializeOIChart();
                    }, 200);
                    return;
                }

                try {                // Create the OI chart
                    oiChart = LightweightCharts.createChart(oiChartContainer, {
                        width: oiChartContainer.clientWidth,
                        height: oiChartContainer.clientHeight,
                        layout: {
                            backgroundColor: 'transparent',
                            textColor: '#ffffff',
                        },
                        grid: {
                            vertLines: { color: 'rgba(59, 130, 246, 0.1)' },
                            horzLines: { color: 'rgba(59, 130, 246, 0.1)' },
                        },
                        crosshair: {
                            mode: LightweightCharts.CrosshairMode.Normal,
                        }, timeScale: {
                            borderColor: 'rgba(59, 130, 246, 0.5)',
                            textColor: '#ffffff',
                            timeVisible: true,
                            secondsVisible: false,
                            tickMarkFormatter: (time) => {
                                const date = new Date(time * 1000);
                                return date.toLocaleTimeString('en-GB', {
                                    hour: '2-digit',
                                    minute: '2-digit',
                                    hour12: false,
                                    timeZone: 'Asia/Kolkata'
                                });
                            },
                        },
                        localization: {
                            timeFormatter: (time) => {
                                const date = new Date(time * 1000);
                                return date.toLocaleString('en-GB', {
                                    hour12: false,
                                    timeZone: 'Asia/Kolkata'
                                });
                            }
                        },
                        rightPriceScale: {
                            borderColor: 'rgba(59, 130, 246, 0.5)',
                            scaleMargins: {
                                top: 0.1,
                                bottom: 0.1
                            },
                            // Format large numbers properly
                            ticksVisible: true,
                            entireTextOnly: false
                        },
                    });

                    // Custom price formatter for large numbers
                    const priceFormatter = (price) => {
                        if (price >= 1000000) {
                            return safeToFixed(price / 1000000, 1) + 'M';
                        } else if (price >= 1000) {
                            return safeToFixed(price / 1000, 1) + 'K';
                        }
                        return safeToFixed(price, 0);
                    };

                    // Add Call_OI line series (red)
                    callOISeries = oiChart.addLineSeries({
                        color: '#ef4444',
                        lineWidth: 2,
                        title: 'Call OI',
                        priceFormat: {
                            type: 'custom',
                            formatter: priceFormatter,
                        },
                    });
                    // Add open_interest line series (green)
                    openInterestSeries = oiChart.addLineSeries({
                        color: '#10b981',
                        lineWidth: 2,
                        title: 'Put_OI',
                        priceFormat: {
                            type: 'custom',
                            formatter: priceFormatter,
                        },
                    });

                    // Handle resize
                    window.addEventListener('resize', () => {
                        if (oiChart) {
                            const isFullSize = document.querySelector('.secondary-chart:nth-child(1)').classList.contains('full-size');
                            if (isFullSize) {
                                const width = Math.max(window.innerWidth - 320, 1000);
                                const height = Math.max(window.innerHeight - 300, 600);
                                oiChart.applyOptions({ width: width, height: height });
                                // Auto-fit content for full-size mode
                                setTimeout(() => {
                                    try {
                                        const timeScale = oiChart.timeScale();
                                        timeScale.fitContent();
                                    } catch (error) {
                                        console.error('❌ Error auto-fitting OI chart on resize:', error);
                                    }
                                }, 100);
                            } else {
                                oiChart.applyOptions({ width: oiChartContainer.clientWidth });
                            }
                        }
                    }); 
                    
                    console.log('✅ OI Chart initialized successfully');
                    
                    // Make OI chart globally accessible for resize function
                    window.oiChart = oiChart;

                    // Setup OI zoom controls after chart initialization
                    setupOIZoomControls();

                } catch (error) {
                    console.error('❌ Error initializing OI chart:', error);
                }
            }

            // Initialize Sentiment Chart
            let sentimentChart;
            let sentimentSeries;
            let sentimentBarSeries; // New bar series for 'sent' column in zoom mode
            let spurtBarSeries; // New bar series for 'spurt' column in zoom mode
            let sentimentZeroLine; // Zero reference line for sentiment bars
            let spurtZeroLine; // Zero reference line for spurt bars

            function initializeSentimentChart() {
                console.log('🔧 Initializing Sentiment chart...');

                const sentimentChartContainer = document.getElementById('sentiment-chart');

                if (!sentimentChartContainer) {
                    console.error('❌ Sentiment Chart container not found!');
                    return;
                }

                console.log('✅ Sentiment Chart container found');

                // Check dimensions and retry if needed
                if (sentimentChartContainer.clientWidth === 0 || sentimentChartContainer.clientHeight === 0) {
                    console.warn('⚠️ Sentiment Chart container has zero dimensions, retrying...');
                    setTimeout(() => {
                        initializeSentimentChart();
                    }, 200);
                    return;
                }

                try {
                    // Create the Sentiment chart
                    sentimentChart = LightweightCharts.createChart(sentimentChartContainer, {
                        width: sentimentChartContainer.clientWidth,
                        height: sentimentChartContainer.clientHeight,
                        layout: {
                            backgroundColor: 'transparent',
                            textColor: '#ffffff',
                        },
                        grid: {
                            vertLines: { color: 'rgba(59, 130, 246, 0.1)' },
                            horzLines: { color: 'rgba(59, 130, 246, 0.1)' },
                        },
                        crosshair: {
                            mode: LightweightCharts.CrosshairMode.Normal,
                        },
                        timeScale: {
                            borderColor: 'rgba(59, 130, 246, 0.5)',
                            textColor: '#ffffff',
                            timeVisible: true,
                            secondsVisible: false,
                            tickMarkFormatter: (time) => {
                                const date = new Date(time * 1000);
                                return date.toLocaleTimeString('en-GB', {
                                    hour: '2-digit',
                                    minute: '2-digit',
                                    hour12: false,
                                    timeZone: 'Asia/Kolkata'
                                });
                            },
                        },
                        rightPriceScale: {
                            borderColor: 'rgba(59, 130, 246, 0.5)',
                            scaleMargins: {
                                top: 0.0,   // Top 50% (0% to 50%)
                                bottom: 0.5
                            },
                        },
                    });

                    // Add trn_oi line series (purple/blue)
                    sentimentSeries = sentimentChart.addLineSeries({
                        color: '#8b5cf6',
                        lineWidth: 2,
                        title: 'Sentiment (trn_oi)',
                    });

                    // Handle resize
                    window.addEventListener('resize', () => {
                        if (sentimentChart) {
                            const isFullSize = document.querySelector('.secondary-chart:nth-child(2)').classList.contains('full-size');
                            if (isFullSize) {
                                const width = Math.max(window.innerWidth - 320, 1000);
                                const height = Math.max(window.innerHeight - 300, 600);
                                sentimentChart.applyOptions({ width: width, height: height });
                                // Auto-fit content for full-size mode
                                setTimeout(() => {
                                    try {
                                        const timeScale = sentimentChart.timeScale();
                                        timeScale.fitContent();
                                    } catch (error) {
                                        console.error('❌ Error auto-fitting Sentiment chart on resize:', error);
                                    }
                                }, 100);
                            } else {
                                sentimentChart.applyOptions({ width: sentimentChartContainer.clientWidth });
                            }
                        }
                    });

                    console.log('✅ Sentiment Chart initialized successfully');
                    
                    // Add double-click event listener for signal bar locking
                    sentimentChart.subscribeClick((param) => {
                        // We'll use the click event and track double-clicks manually
                        handleSentimentChartClick(param);
                    });
                    
                    // Make sentiment chart globally accessible for resize function
                    window.sentimentChart = sentimentChart;

                    // Setup Sentiment zoom controls
                    setupSentimentZoomControls();

                } catch (error) {
                    console.error('❌ Error initializing Sentiment chart:', error);
                }
            }

            // Sentiment Chart Double-Click Handler for Popup Locking
            let lastSentimentClickTime = 0;
            let lastSentimentClickPoint = null;
            
            function handleSentimentChartClick(param) {
                const currentTime = Date.now();
                const doubleClickThreshold = 300; // 300ms for double-click detection
                
                if (!param.point || !param.time) {
                    return;
                }
                
                // Check if this is a double-click
                const isDoubleClick = (currentTime - lastSentimentClickTime) < doubleClickThreshold && 
                                    lastSentimentClickPoint && 
                                    Math.abs(param.point.x - lastSentimentClickPoint.x) < 10 &&
                                    Math.abs(param.point.y - lastSentimentClickPoint.y) < 10;
                
                if (isDoubleClick) {
                    console.log('👆👆 DOUBLE-CLICK detected on sentiment chart signal bar!');
                    
                    // Check if we're in zoom mode and have signal bars
                    const isInZoomMode = document.querySelector('.secondary-chart:nth-child(2)').classList.contains('full-size');
                    
                    if (isInZoomMode && window.sentimentBarData) {
                        // Find the signal bar data for this time point
                        const clickedTime = param.time;
                        const signalBar = window.sentimentBarData.find(bar => Math.abs(bar.time - clickedTime) < 30); // 30 second tolerance
                        
                        if (signalBar) {
                            console.log('🎯 Signal bar found for double-click:', signalBar);
                            
                            // Convert time to readable format
                            const date = new Date(clickedTime * 1000);
                            const timeStr = date.toLocaleTimeString('en-GB', {
                                hour: '2-digit',
                                minute: '2-digit',
                                hour12: false,
                                timeZone: 'Asia/Kolkata'
                            });
                            
                            // Show popup if not already visible
                            if (!secondaryDataPopup || !secondaryDataPopup.classList.contains('show')) {
                                // Trigger the popup to show first
                                simulateHoverOnSignalBar(clickedTime);
                            }
                            
                            // Lock the popup
                            setTimeout(() => {
                                if (isPopupLocked) {
                                    unlockPopup();
                                    console.log(`🔓 Popup UNLOCKED for signal at ${timeStr}`);
                                } else {
                                    lockPopup();
                                    console.log(`🔒 Popup LOCKED for signal at ${timeStr}`);
                                }
                            }, 100);
                            
                        } else {
                            console.log('⚠️ No signal bar found at clicked time');
                        }
                    } else {
                        console.log('⚠️ Double-click ignored - not in zoom mode or no signal bars available');
                    }
                }
                
                // Store current click info for next click
                lastSentimentClickTime = currentTime;
                lastSentimentClickPoint = param.point;
            }
            
            // Helper function to simulate hover on signal bar to show popup
            async function simulateHoverOnSignalBar(time) {
                // This will trigger the existing hover logic to show the popup
                const date = new Date(time * 1000);
                const timeStr = date.toLocaleTimeString('en-US', { 
                    hour12: false, 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                console.log(`🎯 Simulating hover on signal bar at ${timeStr}`);
                
                // Format full datetime for secondary data search using global currentDate
                // Parse currentDate (e.g., "2025-07-03") to get date components
                let dateForSearch = currentDate;
                
                // If currentDate is null or undefined, try to get it from the date picker
                if (!dateForSearch) {
                    const datePicker = document.getElementById('date-select');
                    if (datePicker && datePicker.value) {
                        dateForSearch = datePicker.value;
                        console.log(`🔍 Using date picker value as fallback: ${dateForSearch}`);
                    } else {
                        console.error(`❌ Both currentDate and date picker are null/empty - using current system date`);
                        const today = new Date();
                        const day = String(today.getDate()).padStart(2, '0');
                        const month = String(today.getMonth() + 1).padStart(2, '0');
                        const year = today.getFullYear();
                        dateForSearch = `${year}-${month}-${day}`;
                    }
                }
                
                const [year, month, day] = dateForSearch.split('-');
                
                const fullDateTime1 = `${day}-${month}-${year} ${timeStr}:00`; // 03-07-2025 09:45:00
                const fullDateTime2 = `${year}-${month}-${day} ${timeStr}:00`; // 2025-07-03 09:45:00
                
                console.log(`🔍 Using dateForSearch: ${dateForSearch} (from ${dateForSearch === currentDate ? 'global currentDate' : 'date picker fallback'})`);
                console.log(`🔍 Searching for datetime formats: ${fullDateTime1}, ${fullDateTime2}`);
                
                try {
                    // Load secondary data if not already loaded
                    if (!secondaryData) {
                        console.log(`🔍 Secondary data not loaded, attempting to load for date: ${dateForSearch}`);
                        secondaryData = await loadSecondaryData(dateForSearch);
                    }
                    
                    if (secondaryData) {
                        console.log(`✅ Secondary data loaded successfully - ${secondaryData.length} rows`);
                        const fullDateTime = new Date(time * 1000);
                        const secondaryDataRows = filterSecondaryDataByTime(secondaryData, fullDateTime);
                        
                        // Find corresponding main data point
                        const mainDataPoint = findMainDataPoint(timeStr);
                        console.log(`🔍 Main data point:`, mainDataPoint);
                        
                        console.log(`🔍 About to show popup with ${secondaryDataRows.length} rows`);
                        // Show secondary data popup with main data
                        showSecondaryDataPopup(timeStr, fullDateTime, secondaryDataRows, mainDataPoint);
                    } else {
                        console.error(`❌ Failed to load secondary data for date: ${dateForSearch}`);
                        console.error(`❌ dateForSearch type: ${typeof dateForSearch}, value: "${dateForSearch}"`);
                    }
                } catch (error) {
                    console.error('❌ Error simulating hover:', error);
                }
            }
            function setupSentimentZoomControls() {
                document.getElementById('sentiment-zoom-in').addEventListener('click', () => {
                    console.log('🔍 Sentiment Zoom in button clicked');
                    if (sentimentChart && sentimentChart.timeScale && typeof sentimentChart.timeScale === 'function') {
                        try {
                            const timeScale = sentimentChart.timeScale();
                            const visibleRange = timeScale.getVisibleRange();

                            if (visibleRange) {
                                const rangeSize = visibleRange.to - visibleRange.from;
                                const center = (visibleRange.from + visibleRange.to) / 2;
                                const newRangeSize = rangeSize * 0.7; // Zoom in by 30%

                                timeScale.setVisibleRange({
                                    from: center - newRangeSize / 2,
                                    to: center + newRangeSize / 2
                                });
                                console.log('✅ Sentiment Chart zoomed in successfully');
                            }
                        } catch (error) {
                            console.error('❌ Error zooming in Sentiment chart:', error);
                        }
                    }
                });

                document.getElementById('sentiment-zoom-out').addEventListener('click', () => {
                    console.log('🔍 Sentiment Zoom out button clicked');
                    if (sentimentChart && sentimentChart.timeScale && typeof sentimentChart.timeScale === 'function') {
                        try {
                            const timeScale = sentimentChart.timeScale();
                            const visibleRange = timeScale.getVisibleRange();

                            if (visibleRange) {
                                const rangeSize = visibleRange.to - visibleRange.from;
                                const center = (visibleRange.from + visibleRange.to) / 2;
                                const newRangeSize = rangeSize * 1.4; // Zoom out by 40%

                                timeScale.setVisibleRange({
                                    from: center - newRangeSize / 2,
                                    to: center + newRangeSize / 2
                                });
                                console.log('✅ Sentiment Chart zoomed out successfully');
                            }
                        } catch (error) {
                            console.error('❌ Error zooming out Sentiment chart:', error);
                        }
                    }
                });

                document.getElementById('sentiment-fit-content').addEventListener('click', () => {
                    console.log('📏 Sentiment Fit content button clicked');
                    if (sentimentChart && sentimentChart.timeScale) {
                        try {
                            const timeScale = sentimentChart.timeScale();
                            timeScale.fitContent();
                            console.log('✅ Sentiment Chart fit content applied');
                        } catch (error) {
                            console.error('❌ Error fitting Sentiment chart content:', error);
                        }
                    }
                });
            }

            // OI Chart Zoom Controls
            function setupOIZoomControls() {
                document.getElementById('oi-zoom-in').addEventListener('click', () => {
                    console.log('🔍 OI Zoom in button clicked');
                    if (oiChart && oiChart.timeScale && typeof oiChart.timeScale === 'function') {
                        try {
                            const timeScale = oiChart.timeScale();
                            const visibleRange = timeScale.getVisibleRange();

                            if (visibleRange) {
                                const rangeSize = visibleRange.to - visibleRange.from;
                                const center = (visibleRange.from + visibleRange.to) / 2;
                                const newRangeSize = rangeSize * 0.7; // Zoom in by 30%

                                timeScale.setVisibleRange({
                                    from: center - newRangeSize / 2,
                                    to: center + newRangeSize / 2
                                });
                                console.log('✅ OI Chart zoomed in successfully');
                            } else {
                                console.error('❌ Could not get OI chart visible range');
                            }
                        } catch (error) {
                            console.error('❌ Error zooming in OI chart:', error);
                        }
                    } else {
                        console.error('❌ OI Chart or timeScale not properly initialized');
                    }
                });

                document.getElementById('oi-zoom-out').addEventListener('click', () => {
                    console.log('🔍 OI Zoom out button clicked');
                    if (oiChart && oiChart.timeScale && typeof oiChart.timeScale === 'function') {
                        try {
                            const timeScale = oiChart.timeScale();
                            const visibleRange = timeScale.getVisibleRange();

                            if (visibleRange) {
                                const rangeSize = visibleRange.to - visibleRange.from;
                                const center = (visibleRange.from + visibleRange.to) / 2;
                                const newRangeSize = rangeSize * 1.4; // Zoom out by 40%

                                timeScale.setVisibleRange({
                                    from: center - newRangeSize / 2,
                                    to: center + newRangeSize / 2
                                });
                                console.log('✅ OI Chart zoomed out successfully');
                            } else {
                                console.error('❌ Could not get OI chart visible range');
                            }
                        } catch (error) {
                            console.error('❌ Error zooming out OI chart:', error);
                        }
                    } else {
                        console.error('❌ OI Chart or timeScale not properly initialized');
                    }
                });

                document.getElementById('oi-fit-content').addEventListener('click', () => {
                    console.log('📏 OI Fit content button clicked');
                    if (oiChart && oiChart.timeScale) {
                        try {
                            const timeScale = oiChart.timeScale();
                            timeScale.fitContent();
                            console.log('✅ OI Chart fit content applied');
                        } catch (error) {
                            console.error('❌ Error fitting OI chart content:', error);
                        }
                    } else {
                        console.error('❌ OI Chart or timeScale not available');
                    }
                });
            }

            // Global variables for secondary data loading
            let secondaryDataCache = {}; // Cache for big_oi_summary data
            let currentSecondaryDate = null; // Track current date for secondary data

            // Secondary Data Popup Functions
            
            function lockPopup() {
                isPopupLocked = true;
                console.log('🔒 LOCKING POPUP');
                const popup = document.getElementById('secondary-data-popup');
                const statusDiv = document.getElementById('debug-status');
                const lockBtn = document.getElementById('popup-lock-btn');
                
                if (popup) {
                    popup.classList.add('locked');
                    // Update title to show locked state
                    const titleDiv = document.getElementById('popup-title');
                    if (titleDiv && !titleDiv.textContent.includes('🔒')) {
                        titleDiv.textContent = '🔒 ' + titleDiv.textContent;
                    }
                    
                    // Update lock button icon
                    if (lockBtn) {
                        lockBtn.textContent = '🔒';
                        lockBtn.title = 'Click to unlock popup (L key also works)';
                    }
                    
                    // Visual flash effect
                    popup.style.backgroundColor = 'rgba(245, 158, 11, 0.2)';
                    setTimeout(() => {
                        popup.style.backgroundColor = 'rgba(15, 23, 42, 0.98)';
                    }, 300);
                    
                    if (statusDiv) statusDiv.textContent = 'Status: LOCKED 🔒';
                }
                console.log('📌 Popup locked');
            }
            
            function unlockPopup() {
                isPopupLocked = false;
                console.log('🔓 UNLOCKING POPUP');
                const popup = document.getElementById('secondary-data-popup');
                const statusDiv = document.getElementById('debug-status');
                const lockBtn = document.getElementById('popup-lock-btn');
                
                if (popup) {
                    popup.classList.remove('locked');
                    // Remove lock icon from title
                    const titleDiv = document.getElementById('popup-title');
                    if (titleDiv && titleDiv.textContent.includes('🔒')) {
                        titleDiv.textContent = titleDiv.textContent.replace('🔒 ', '');
                    }
                    
                    // Update lock button icon
                    if (lockBtn) {
                        lockBtn.textContent = '🔓';
                        lockBtn.title = 'Click to lock popup (L key also works)';
                    }
                    
                    // Visual flash effect
                    popup.style.backgroundColor = 'rgba(16, 185, 129, 0.2)';
                    setTimeout(() => {
                        popup.style.backgroundColor = 'rgba(15, 23, 42, 0.98)';
                    }, 300);
                    
                    if (statusDiv) statusDiv.textContent = 'Status: UNLOCKED 🔓';
                }
                console.log('🔓 Popup unlocked');
            }
            
            function togglePopupLock() {
                console.log('🔄 Toggle popup lock button clicked');
                if (isPopupLocked) {
                    unlockPopup();
                } else {
                    lockPopup();
                }
            }
            
            // Toggle function for collapsible sections
            function toggleSection(sectionId) {
                const content = document.getElementById(sectionId + '-content');
                const icon = document.getElementById(sectionId + '-icon');
                const count = document.getElementById(sectionId + '-count');
                
                if (!content || !icon) {
                    console.warn(`⚠️ Section elements not found for: ${sectionId}`);
                    return;
                }
                
                const isCollapsed = content.style.display === 'none';
                
                if (isCollapsed) {
                    // Expand section
                    content.style.display = 'block';
                    icon.textContent = '−';
                    if (count) count.style.display = 'none';
                } else {
                    // Collapse section
                    content.style.display = 'none';
                    icon.textContent = '+';
                    if (count) count.style.display = 'inline';
                }
                
                console.log(`📱 Toggled section: ${sectionId}, expanded: ${isCollapsed}`);
            }
            
            // Function to update section count displays
            function updateSectionCount(sectionId, count) {
                const countElement = document.getElementById(sectionId + '-count');
                if (countElement) {
                    countElement.textContent = `[${count}]`;
                }
            }
            
            // Find main data point by time
            function findMainDataPoint(timePoint) {
                if (!originalData || originalData.length === 0) {
                    console.warn('⚠️ No original data available');
                    return null;
                }
                
                console.log(`🔍 Looking for time point: "${timePoint}" in ${originalData.length} data points`);
                console.log(`🔍 Sample time_str values:`, originalData.slice(0, 5).map(d => d.time_str));
                
                // Find exact match first using time_str field
                let dataPoint = originalData.find(d => d.time_str === timePoint);
                console.log(`🔍 Exact match result:`, dataPoint ? 'FOUND' : 'NOT FOUND');
                
                // if (!dataPoint) {
                //     // Try matching without seconds (e.g. "10:19" matches "10:19:00")
                //     dataPoint = originalData.find(d => d.time_str && d.time_str.startsWith(timePoint));
                //     console.log(`🔍 Partial match result:`, dataPoint ? 'FOUND' : 'NOT FOUND');
                // }
                
                // if (!dataPoint) {
                //     console.log(`🔍 No direct match found for "${timePoint}", trying closest match...`);
                //     // Find closest match by converting timestamps
                //     const targetHour = parseInt(timePoint.split(':')[0]);
                //     const targetMinute = parseInt(timePoint.split(':')[1]);
                    
                //     dataPoint = originalData.reduce((closest, current) => {
                //         if (!current.time_str) return closest;
                        
                //         const currentParts = current.time_str.split(':');
                //         const currentHour = parseInt(currentParts[0]);
                //         const currentMinute = parseInt(currentParts[1]);
                        
                //         const currentDiff = Math.abs((currentHour * 60 + currentMinute) - (targetHour * 60 + targetMinute));
                        
                //         if (!closest || !closest.time_str) return current;
                        
                //         const closestParts = closest.time_str.split(':');
                //         const closestHour = parseInt(closestParts[0]);
                //         const closestMinute = parseInt(closestParts[1]);
                //         const closestDiff = Math.abs((closestHour * 60 + closestMinute) - (targetHour * 60 + targetMinute));
                        
                //         return currentDiff < closestDiff ? current : closest;
                //     });
                //     console.log(`🔍 Closest match found:`, dataPoint ? dataPoint.time_str : 'NONE');
                // }
                
                console.log(`🔍 Found main data point for time ${timePoint}:`, dataPoint ? {
                    time_str: dataPoint.time_str,
                    trust_value: dataPoint.trust_value,
                    direction: dataPoint.direction,
                    safety_strk: dataPoint.safety_strk,
                    trial_strk: dataPoint.trial_strk,
                    safety_entry: dataPoint.safety_entry,
                    safety_DL: dataPoint.safety_DL,
                    trial_entry: dataPoint.trial_entry,
                    trial_DL: dataPoint.trial_DL,
                    sent: dataPoint.sent
                } : null);
                return dataPoint;
            }

            function showSecondaryDataPopup(timeStr, fullDateTime, secondaryDataRows, mainDataPoint) {
                console.log(`🎯 POPUP DEBUG: showSecondaryDataPopup called with timeStr=${timeStr}, rows=${secondaryDataRows.length}`);
                
                if (!secondaryDataPopup) {
                    secondaryDataPopup = document.getElementById('secondary-data-popup');
                    console.log(`🎯 POPUP DEBUG: secondaryDataPopup element found:`, !!secondaryDataPopup);
                }
                
                // Don't update content if popup is locked (except if it's the same time)
                if (isPopupLocked) {
                    const titleDiv = document.getElementById('popup-title');
                    // Updated regex to match new format: [DD-MON-YYYY :: HH:MM]
                    const currentTime = titleDiv ? titleDiv.textContent.match(/@ \[\d{2}-[A-Z]{3}-\d{4} :: (\d{2}:\d{2})\]/) : null;
                    const currentTimeStr = currentTime ? currentTime[1] : '';
                    
                    if (currentTimeStr === timeStr) {
                        console.log('📊 Popup locked - same time, allowing update');
                    } else {
                        console.log('📊 Popup locked - different time, preventing update');
                        return;
                    }
                }
                
                // Clear any pending hide timeout
                if (popupHideTimeout) {
                    clearTimeout(popupHideTimeout);
                    popupHideTimeout = null;
                }
                
                const contentDiv = document.getElementById('secondary-data-content');
                const titleDiv = document.getElementById('popup-title');
                
                // Create formatted date-time string for popup title
                function createFormattedDateTime(timeStr) {
                    // Get current date from global currentDate variable or use today
                    let dateStr = currentDate;
                    console.log(`🔍 createFormattedDateTime: Using global currentDate = "${currentDate}"`);
                    console.log(`🔍 createFormattedDateTime: currentDate type = ${typeof currentDate}`);
                    console.log(`🔍 createFormattedDateTime: currentDate is null? ${currentDate === null}`);
                    
                    // If currentDate is null or undefined, try to get it from the date picker
                    if (!dateStr) {
                        const datePicker = document.getElementById('date-select');
                        if (datePicker && datePicker.value) {
                            dateStr = datePicker.value;
                            console.log(`🔍 createFormattedDateTime: Using date picker value = "${dateStr}"`);
                        } else {
                            const today = new Date();
                            const day = String(today.getDate()).padStart(2, '0');
                            const month = String(today.getMonth() + 1).padStart(2, '0');
                            const year = today.getFullYear();
                            dateStr = `${year}-${month}-${day}`;
                            console.log(`🔍 createFormattedDateTime: currentDate was null, using today = "${dateStr}"`);
                            console.log(`🚨 WARNING: currentDate was null and no date picker value - this means the date picker selection is not being used!`);
                        }
                    }
                    
                    // Parse the date from YYYY-MM-DD format
                    const [year, month, day] = dateStr.split('-');
                    const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 
                                       'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                    const monthName = monthNames[parseInt(month) - 1];
                    
                    // Format as [DD-MON-YYYY :: 24HH:MM]
                    return `[${day}-${monthName}-${year} :: ${timeStr}]`;
                }
                
                const formattedDateTime = createFormattedDateTime(timeStr);
                
                if (secondaryDataRows.length === 0) {
                    titleDiv.textContent = `📊 Signal data @ ${formattedDateTime} - No Data`;
                    contentDiv.innerHTML = `
                        <div class="popup-content">
                            <div class="no-data">
                                No options data found for ${formattedDateTime}
                            </div>
                        </div>
                    `;
                } else {
                    // Parse and analyze the options data with main data
                    const analysisData = analyzeOptionsData(secondaryDataRows, timeStr, mainDataPoint);
                    
                    // Update title with signal data
                    titleDiv.textContent = `📊 Signal data @ ${formattedDateTime} with ${analysisData.signalValue}, sent ${analysisData.sentValue}`;
                    
                    contentDiv.innerHTML = createVisualPopupContent(analysisData);
                    
                    // Debug: Log the analysis data being passed to popup
                    console.log('🔍 Analysis data being passed to popup:', {
                        safetyStrk: analysisData.safetyStrk,
                        trialStrk: analysisData.trialStrk,
                        safetyEntry: analysisData.safetyEntry,
                        safetyDL: analysisData.safetyDL,
                        trialEntry: analysisData.trialEntry,
                        trialDL: analysisData.trialDL
                    });
                    
                    // Animate bars after a short delay
                    setTimeout(() => {
                        animateBars();
                    }, 100);
                }
                
                // Check if Chart 3 is in zoom mode
                const chart3Element = document.querySelector('.secondary-chart:nth-child(2)');
                const isChart3ZoomMode = chart3Element && chart3Element.classList.contains('full-size');
                
                // Handle popup positioning based on zoom mode
                if (isChart3ZoomMode) {
                    // In zoom mode: position as fixed panel within chart-3 container
                    secondaryDataPopup.classList.remove('zoom-mode');
                    secondaryDataPopup.classList.add('fixed-panel');
                    chart3Element.classList.add('fixed-panel-active');
                    chart3Element.classList.remove('popup-active');
                    
                    // Append popup to chart-3 container instead of body
                    if (secondaryDataPopup.parentElement !== chart3Element) {
                        chart3Element.appendChild(secondaryDataPopup);
                    }
                    
                    console.log('📊 Fixed panel positioned for Chart 3 zoom mode');
                } else {
                    // Normal mode: position popup as fixed overlay
                    secondaryDataPopup.classList.remove('zoom-mode', 'fixed-panel');
                    if (chart3Element) {
                        chart3Element.classList.remove('popup-active', 'fixed-panel-active');
                    }
                    
                    // Append popup back to body if it's not there
                    if (secondaryDataPopup.parentElement !== document.body) {
                        document.body.appendChild(secondaryDataPopup);
                    }
                    
                    console.log('📊 Popup positioned for normal mode');
                }
                
                // Show popup with animation
                secondaryDataPopup.classList.remove('hiding');
                secondaryDataPopup.classList.add('show');
                
                // Reinitialize event listeners after positioning changes
                setTimeout(() => {
                    initializePopupEventListeners();
                    console.log('🔄 Event listeners reinitialized after positioning');
                }, 100);
                
                console.log(`📊 Visual popup shown for ${timeStr} with ${secondaryDataRows.length} rows`);
            }

            // Find min/max trn_oi values and their times up to the specified time
            function findTrnOiRangeUpToTime(currentTimeStr) {
                if (!originalData || originalData.length === 0) {
                    console.warn('⚠️ No original data available for trn_oi range calculation');
                    return {
                        minTime: 'N/A',
                        maxTime: 'N/A',
                        minValue: 0,
                        maxValue: 0
                    };
                }
                
                console.log(`🔍 Finding trn_oi range up to (but excluding) time: ${currentTimeStr}`);
                
                // Filter data up to current time (EXCLUDING current row)
                const dataUpToNow = originalData.filter(point => {
                    if (!point.time_str || point.trn_oi === undefined) return false;
                    
                    // Compare time strings (assuming HH:MM format)
                    const pointTime = point.time_str;
                    const currentTime = currentTimeStr;
                    
                    // Convert to minutes for comparison
                    const pointMinutes = timeStringToMinutes(pointTime);
                    const currentMinutes = timeStringToMinutes(currentTime);
                    
                    // EXCLUDE current row - only use data BEFORE current time
                    return pointMinutes < currentMinutes;
                });
                
                console.log(`📊 Filtered ${dataUpToNow.length} data points up to (excluding) ${currentTimeStr}`);
                
                if (dataUpToNow.length === 0) {
                    return {
                        minTime: 'N/A',
                        maxTime: 'N/A',
                        minValue: 0,
                        maxValue: 0
                    };
                }
                
                // Find min and max trn_oi values
                let minPoint = dataUpToNow[0];
                let maxPoint = dataUpToNow[0];
                
                for (const point of dataUpToNow) {
                    if (point.trn_oi < minPoint.trn_oi) {
                        minPoint = point;
                    }
                    if (point.trn_oi > maxPoint.trn_oi) {
                        maxPoint = point;
                    }
                }
                
                const result = {
                    minTime: minPoint.time_str || 'N/A',
                    maxTime: maxPoint.time_str || 'N/A',
                    minValue: minPoint.trn_oi || 0,
                    maxValue: maxPoint.trn_oi || 0
                };
                
                console.log(`📊 TRN_OI Range up to ${currentTimeStr}:`, result);
                return result;
            }
            
            // Helper function to convert time string to minutes
            function timeStringToMinutes(timeStr) {
                if (!timeStr) return 0;
                const parts = timeStr.split(':');
                if (parts.length !== 2) return 0;
                const hours = parseInt(parts[0]) || 0;
                const minutes = parseInt(parts[1]) || 0;
                return hours * 60 + minutes;
            }

            function analyzeOptionsData(rows, timeStr, mainDataPoint) {
                const atmOptions = [];
                const otmOptions = [];
                let totalVolume = 0;
                let totalOI = 0;
                let bullishSignals = 0;
                let bearishSignals = 0;
                
                console.log(`🔍 Analyzing ${rows.length} rows from secondary CSV`);
                console.log(`🔍 Main data point:`, mainDataPoint);
                console.log(`🔍 Sample row keys:`, Object.keys(rows[0] || {}));
                
                // Extract data from main CSV
                const signalValue = mainDataPoint ? parseFloat(mainDataPoint.sent || 0) : 0;
                const sentValue = mainDataPoint ? parseFloat(mainDataPoint.sent || 0) : 0;
                const spurtValue = mainDataPoint ? parseFloat(mainDataPoint.spurt || 0) : 0;
                const trustValue = mainDataPoint ? parseFloat(mainDataPoint.trust_value || 0) : 50;
                const direction = mainDataPoint ? parseInt(mainDataPoint.direction || 0) : 0;
                const safetyStrk = mainDataPoint ? (mainDataPoint.safety_strk || '') : '';
                const trialStrk = mainDataPoint ? (mainDataPoint.trial_strk || '') : '';
                const safetyEntry = mainDataPoint ? parseFloat(mainDataPoint.safety_entry || 0) : 0;
                const safetyDL = mainDataPoint ? parseFloat(mainDataPoint.safety_DL || 0) : 0;
                const trialEntry = mainDataPoint ? parseFloat(mainDataPoint.trial_entry || 0) : 0;
                const trialDL = mainDataPoint ? parseFloat(mainDataPoint.trial_DL || 0) : 0;
                const atmSent = mainDataPoint ? parseFloat(mainDataPoint.atm_sent || 0) : 0;
                const otmSent = mainDataPoint ? parseFloat(mainDataPoint.otm_sent || 0) : 0;
                const spotValue = mainDataPoint ? parseFloat(mainDataPoint.open || 0) : 0;
                const indexName = INDEX_CONFIG[currentIndex] ? INDEX_CONFIG[currentIndex].title : currentIndex;
                
                // Extract trn_oi trend data and calculate range up to current time
                const trnOiValue = mainDataPoint ? parseFloat(mainDataPoint.trn_oi || 0) : 0;
                const upPct = mainDataPoint ? parseFloat(mainDataPoint.up_pct || 0) : 0;
                const downPct = mainDataPoint ? parseFloat(mainDataPoint.down_pct || 0) : 0;
                
                // Debug log the up_pct value
                console.log(`🔍 TRN_OI Debug for ${timeStr}:`, {
                    trnOiValue,
                    upPct,
                    downPct,
                    upPctType: typeof upPct,
                    upPctCondition: upPct !== 0,
                    willDisplay: upPct !== 0 ? 'YES' : 'NO'
                });
                
                // Find min/max trn_oi values and times up to current timeStr
                const trnOiRangeData = findTrnOiRangeUpToTime(timeStr);
                
                console.log(`🔍 Main CSV data:`, {
                    signalValue,
                    sentValue,
                    spurtValue,
                    trustValue,
                    direction,
                    safetyStrk,
                    trialStrk,
                    safetyEntry,
                    safetyDL,
                    trialEntry,
                    trialDL,
                    atmSent,
                    otmSent
                });
                
                console.log(`🔍 Raw main data point:`, mainDataPoint);
                
                // SPECIFIC DEBUG FOR 10:19
                if (timeStr === '10:19') {
                    console.log(`🚨 DEBUGGING 10:19 SPECIFICALLY:`);
                    console.log(`🚨 mainDataPoint exists:`, !!mainDataPoint);
                    if (mainDataPoint) {
                        console.log(`🚨 Raw safety_entry:`, mainDataPoint.safety_entry);
                        console.log(`🚨 Raw safety_DL:`, mainDataPoint.safety_DL);
                        console.log(`🚨 Raw trial_entry:`, mainDataPoint.trial_entry);
                        console.log(`🚨 Raw trial_DL:`, mainDataPoint.trial_DL);
                        console.log(`🚨 All properties:`, Object.keys(mainDataPoint));
                    }
                }

                rows.forEach((row, index) => {
                    // Extract values from the actual CSV columns
                    const lvl = (row.lvl || '').toString().trim();
                    const instr = (row.instr || '').toString().trim();
                    const diffPct = parseFloat(row.diff_pct || 0);
                    const strikePrice = parseFloat(row.strk || row.strike_price || 0); // Use strk column first
                    const oi = parseFloat(row.oi || row.open_interest || 0);
                    const volume = parseFloat(row.volume || 0);
                    const right = (row.right || '').toString().toLowerCase();
                    
                    console.log(`🔍 Row ${index + 1}: lvl="${lvl}", instr="${instr}", strk=${strikePrice}, diff_pct=${diffPct}`);
                    
                    totalVolume += volume;
                    totalOI += oi;
                    
                    // Create option data object
                    const optionData = {
                        instr: instr,
                        strike: strikePrice,
                        diffPct: diffPct,
                        oi: oi,
                        volume: volume,
                        right: right,
                        lvl: lvl
                    };
                    
                    // Filter into ATM/OTM based on 'lvl' column
                    if (lvl.includes('OTM')) {
                        otmOptions.push(optionData);
                        console.log(`📊 Added to OTM: ${instr} (strk: ${strikePrice}, diff_pct: ${diffPct}%)`);
                    } else {
                        atmOptions.push(optionData);
                        console.log(`📊 Added to ATM: ${instr} (strk: ${strikePrice}, diff_pct: ${diffPct}%)`);
                    }
                    
                    // Count bullish/bearish signals based on diff_pct
                    if (diffPct > 0) bullishSignals++;
                    else if (diffPct < 0) bearishSignals++;
                });
                
                // Sort by strk column in descending order (highest strike first)
                atmOptions.sort((a, b) => b.strike - a.strike);
                otmOptions.sort((a, b) => b.strike - a.strike);
                
                // Use trust_value for confidence, direction for recommendation
                const confidence = Math.round(trustValue); // Use trust_value from main CSV
                let recommendation = 'NEUTRAL';
                if (direction === 1) recommendation = 'UP';
                else if (direction === -1) recommendation = 'DOWN';
                
                console.log(`📊 Analysis complete:`, {
                    atmCount: atmOptions.length,
                    otmCount: otmOptions.length,
                    confidence: `${confidence}% (from trust_value)`,
                    recommendation: `${recommendation} (from direction: ${direction})`,
                    signalValue,
                    sentValue
                });
                
                return {
                    timeStr,
                    signalValue,
                    sentValue,
                    spurtValue,
                    atmOptions: atmOptions, // Show all ATM options
                    otmOptions: otmOptions, // Show all OTM options
                    totalVolume,
                    totalOI,
                    confidence,
                    recommendation,
                    direction,
                    safetyStrk,
                    trialStrk,
                    safetyEntry,
                    safetyDL,
                    trialEntry,
                    trialDL,
                    atmSent,
                    otmSent,
                    bullishSignals,
                    bearishSignals,
                    totalEntries: rows.length,
                    spotValue,
                    indexName,
                    // trn_oi trend data
                    trnOiValue,
                    upPct,
                    downPct,
                    // trn_oi range timing data
                    trnOiRangeData
                };
            }



            // Calculate position for trend bar indicator based on up_pct and down_pct
            function calculateTrendPosition(upPct, downPct) {
                // up_pct represents distance from the green 100% line
                // up_pct = 0 → at green line (0% from top)
                // up_pct = 10.75 → 10.75% down from green line
                // up_pct = 100 → at red 0% line (100% from top)
                
                console.log(`🎯 calculateTrendPosition: upPct=${upPct}, position=${upPct}% from top`);
                
                if (upPct <= 0) {
                    return 0; // At green line (top)
                }
                if (upPct >= 100) {
                    return 100; // At red line (bottom)
                }
                
                // Direct mapping: upPct = distance from green line
                return upPct;
            }
            
            function getDynamicBarLayout(upPct) {
                // Determine what the bar should show based on upPct
                console.log(`🎯 getDynamicBarLayout: upPct=${upPct}`);
                
                if (upPct <= 0) {
                    // Negative case: Show range from upPct to 100
                    const layout = {
                        topValue: 100,
                        bottomValue: upPct,
                        zeroPos: upPct === 0 ? 100 : ((0 - upPct) / (100 - upPct)) * 100,
                        currentPos: 0,
                        range: `${upPct} to 100`
                    };
                    console.log(`🎯 Negative case:`, layout);
                    return layout;
                }
                
                if (upPct <= 100) {
                    // Normal case: Show 0 to 100 range
                    const layout = {
                        topValue: 100,
                        bottomValue: 0,
                        zeroPos: 100,
                        currentPos: 100 - upPct,
                        range: "0 to 100"
                    };
                    console.log(`🎯 Normal case:`, layout);
                    return layout;
                }
                
                // High case: Show 100 to upPct range, with 0 at 1/3 from bottom
                const rangeSize = upPct - 100;
                const zeroDistance = rangeSize / 3; // 0 should be 1/3 from bottom
                const layout = {
                    topValue: 100,
                    bottomValue: upPct,
                    zeroPos: 100 - (zeroDistance / rangeSize) * 100, // 0 at 1/3 from bottom
                    currentPos: 100,
                    range: `100 to ${upPct}`
                };
                console.log(`🎯 High case:`, layout);
                return layout;
            }

            function createVisualPopupContent(data) {
                return `
                    <div class="popup-content">
                        <!-- Top Section: Grid Layout -->
                        <div class="top-section">
                            <!-- Recommendation: Column 1, Row 1 -->
                            <div class="recommendation-section">
                                <div class="recommendation-title">Recommendation</div>
                                <div class="recommendation-content">
                                    <div class="recommendation-display">
                                        <span class="recommendation-text">${data.recommendation}</span>
                                        <span class="recommendation-arrow ${data.recommendation === 'DOWN' ? 'put-arrow' : 'call-arrow'}">${data.recommendation === 'UP' ? '⇑' : data.recommendation === 'DOWN' ? '⇓' : '–'}</span>
                                    </div>
                                    <div class="recommendation-note">T&C** apply</div>
                                </div>
                            </div>

                            <!-- Signal Confidence: Column 1, Row 2 -->
                            <div class="signal-confidence">
                                <h3>Signal Confidence</h3>
                                <div class="confidence-bar">
                                    <div class="confidence-fill" style="width: 0%" data-width="${data.confidence}%">
                                        <div class="confidence-text">${data.confidence}%</div>
                                    </div>
                                </div>
                            </div>

                            <!-- TRN_OI Range: Column 2, Spans Rows 1-2 -->
                            <div class="trend-bar-section">
                                <div class="trend-bar-title">TRN_OI Range</div>
                                <div style="display: flex; align-items: center; margin: 16px 0;">
                                    <div class="trend-bar-container">
                                        <!-- Current position indicator (orange) -->
                                        <div class="trend-bar-indicator" style="top: ${calculateTrendPosition(data.upPct, data.downPct)}%"></div>
                                        
                                        <!-- 100 line with time on left -->
                                        <div class="range-marker range-marker-100" style="top: 0%">
                                            <div class="marker-time-left">[${data.trnOiRangeData ? data.trnOiRangeData.maxTime : 'N/A'}]</div>
                                            <div class="marker-line"></div>
                                            <div class="marker-label">100</div>
                                        </div>
                                        
                                        <!-- 0 line with time on left -->
                                        <div class="range-marker range-marker-0" style="top: 100%">
                                            <div class="marker-time-left">[${data.trnOiRangeData ? data.trnOiRangeData.minTime : 'N/A'}]</div>
                                            <div class="marker-line"></div>
                                            <div class="marker-label">0</div>
                                        </div>
                                        
                                        <!-- Current value marker (orange) -->
                                        <div class="range-marker range-marker-current" style="top: ${calculateTrendPosition(data.upPct, data.downPct)}%">
                                            <div class="marker-line-current"></div>
                                            <div class="marker-label-current">${data.upPct}%</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="trend-bar-value">${formatNumber(data.trnOiValue)}</div>
                            </div>
                        </div>

                        <!-- Second Row: Sentiment Value + Instruments Table -->
                        <div class="second-row">
                            <div class="sentiment-values-section">
                                <div class="sentiment-title">Sentiment Values @ ${data.timeStr}</div>
                                <div class="sentiment-displays">
                                    <div class="sentiment-item">
                                        <div class="sentiment-label">Signal:</div>
                                        <div class="sentiment-value ${data.sentValue >= 0 ? 'positive' : 'negative'}" style="font-size: 20px; font-weight: bold;">${safeToFixed(data.sentValue, 2)}</div>
                                    </div>
                                    <div class="sentiment-item">
                                        <div class="sentiment-label">Spurt:</div>
                                        <div class="sentiment-value ${data.spurtValue >= 0 ? 'positive' : 'negative'}" style="font-size: 20px; font-weight: bold;">${safeToFixed(data.spurtValue, 2)}</div>
                                    </div>
                                </div>
                            </div>

                            <div class="instruments-section-compact">
                                <div class="instruments-table">
                                    <div class="instruments-header">
                                        <div class="instr-col">Action</div>
                                        <div class="instr-col">Instr</div>
                                        <div class="instr-col">Entry Price</div>
                                        <div class="instr-col">Day Low</div>
                                    </div>
                                    ${data.safetyStrk ? `
                                    <div class="instruments-row">
                                        <div class="instr-col">Safety</div>
                                        <div class="instr-col">${data.safetyStrk}</div>
                                        <div class="instr-col">${data.safetyEntry !== undefined && data.safetyEntry !== null ? safeToFixed(data.safetyEntry, 2) : '-'}</div>
                                        <div class="instr-col">${data.safetyDL !== undefined && data.safetyDL !== null ? safeToFixed(data.safetyDL, 2) : '-'}</div>
                                    </div>
                                    ` : ''}
                                    ${data.trialStrk ? `
                                    <div class="instruments-row">
                                        <div class="instr-col">Trial</div>
                                        <div class="instr-col">${data.trialStrk}</div>
                                        <div class="instr-col">${data.trialEntry !== undefined && data.trialEntry !== null ? safeToFixed(data.trialEntry, 2) : '-'}</div>
                                        <div class="instr-col">${data.trialDL !== undefined && data.trialDL !== null ? safeToFixed(data.trialDL, 2) : '-'}</div>
                                    </div>
                                    ` : ''}
                                </div>
                            </div>
                        </div>

                        <!-- Summary Stats -->
                        <div class="summary-stats">
                            <div class="stat-item">
                                <div class="stat-label">Total Entries</div>
                                <div class="stat-value">${data.totalEntries}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Total Volume</div>
                                <div class="stat-value">${formatNumber(data.totalVolume)}</div>
                            </div>
                        </div>

                        <!-- Sentiment Graphs with ATM/OTM Labels -->
                        <div class="sentiment-section">
                            <div class="sentiment-title">ATM & OTM Sentiment Analysis, ${data.indexName} spot @ ${safeToFixed(data.spotValue, 2)}</div>
                            <div class="sentiment-graphs">
                                <div class="sentiment-graph">
                                    <div class="sentiment-subtitle">ATM Sentiment :: <span class="${data.atmSent >= 0 ? 'positive' : 'negative'}">[${safeToFixed(data.atmSent, 2)}]</span></div>
                                    ${createSentimentBars(data.atmOptions, 'atm')}
                                </div>
                                <div class="sentiment-graph">
                                    <div class="sentiment-subtitle">OTM Sentiment :: <span class="${data.otmSent >= 0 ? 'positive' : 'negative'}">[${safeToFixed(data.otmSent, 2)}]</span></div>
                                    ${createSentimentBars(data.otmOptions, 'otm')}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            function createSentimentBars(options, prefix) {
                if (options.length === 0) {
                    return '<div style="text-align: center; color: #94a3b8; font-size: 10px; padding: 20px;">No data</div>';
                }

                // Find max absolute diff_pct for scaling bars (bars will extend max 50% from center)
                const maxDiffPct = Math.max(...options.map(opt => Math.abs(opt.diffPct)), 1);
                
                console.log(`📊 Creating ${prefix} bars with max diff_pct: ${maxDiffPct}`);

                return options.map((opt, index) => {
                    // Scale to 50% max width (from center to edge)
                    const percentage = (Math.abs(opt.diffPct) / maxDiffPct) * 50;
                    const isPositive = opt.diffPct >= 0;
                    
                    // Clean up instrument name for display (remove .0 decimals if present)
                    const displayInstr = opt.instr.replace('.0-', '-');
                    
                    // Determine if this is a Call or Put strike for color differentiation
                    const isCall = displayInstr.toLowerCase().includes('call');
                    const isPut = displayInstr.toLowerCase().includes('put');
                    const strikeClass = isCall ? 'call-strike' : (isPut ? 'put-strike' : '');
                    
                    console.log(`📊 ${prefix} bar ${index + 1}: ${displayInstr} = ${opt.diffPct}% (${percentage}% width, ${isPositive ? 'positive' : 'negative'})`);
                    
                    return `
                        <div class="bar-item">
                            <div class="bar-label ${strikeClass}">${displayInstr}</div>
                            <div class="bar-container">
                                <div class="bar-fill ${isPositive ? 'positive' : 'negative'}" 
                                     style="width: 0%" 
                                     data-width="${percentage}%">
                                </div>
                                <div class="bar-value">${safeToFixed(opt.diffPct, 1)}%</div>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            function animateBars() {
                // Animate confidence bar
                const confidenceFill = document.querySelector('.confidence-fill');
                if (confidenceFill) {
                    const targetWidth = confidenceFill.getAttribute('data-width');
                    confidenceFill.style.width = targetWidth;
                }

                // Animate sentiment bars
                const barFills = document.querySelectorAll('.bar-fill');
                barFills.forEach((bar, index) => {
                    setTimeout(() => {
                        const targetWidth = bar.getAttribute('data-width');
                        if (targetWidth) {
                            bar.style.width = targetWidth;
                        }
                    }, index * 50); // Stagger animation
                });
            }

            function formatNumber(num) {
                if (num >= 10000000) return safeToFixed(num / 10000000, 1) + 'Cr';
                if (num >= 100000) return safeToFixed(num / 100000, 1) + 'L';
                if (num >= 1000) return safeToFixed(num / 1000, 1) + 'K';
                return num.toString();
            }

            // Format large numbers for compact display (XXX.YY format with K/M suffixes)
            function formatCompactNumber(num) {
                if (num === null || num === undefined || isNaN(num)) {
                    return '0.00';
                }
                
                const absNum = Math.abs(num);
                let formatted = '';
                
                if (absNum >= 1000000) {
                    // Millions
                    const millions = num / 1000000;
                    formatted = safeToFixed(millions, 2) + 'M';
                } else if (absNum >= 1000) {
                    // Thousands
                    const thousands = num / 1000;
                    formatted = safeToFixed(thousands, 2) + 'K';
                } else {
                    // Less than 1000, show as is with 2 decimal places
                    formatted = safeToFixed(num, 2);
                }
                
                return formatted;
            }

            // Test the compact number formatting function
            console.log('🧮 Testing formatCompactNumber function:');
            console.log('  1234567 →', formatCompactNumber(1234567));     // Should be 1.23M
            console.log('  987654 →', formatCompactNumber(987654));       // Should be 987.65K
            console.log('  12345 →', formatCompactNumber(12345));         // Should be 12.35K
            console.log('  999 →', formatCompactNumber(999));             // Should be 999.00
            console.log('  -1500000 →', formatCompactNumber(-1500000));   // Should be -1.50M
            console.log('  0 →', formatCompactNumber(0));                 // Should be 0.00
            
            function hideSecondaryDataPopup(immediate = false, force = false) {
                if (!secondaryDataPopup) return;
                
                // Don't hide if popup is locked unless forced
                if (isPopupLocked && !force) {
                    console.log('📊 Popup hide prevented - popup is locked');
                    return;
                }
                
                // If forcing close, unlock first
                if (force && isPopupLocked) {
                    unlockPopup();
                }
                
                // Clean up zoom mode classes and positioning
                const chart3Element = document.querySelector('.secondary-chart:nth-child(2)');
                if (chart3Element) {
                    chart3Element.classList.remove('popup-active', 'fixed-panel-active');
                }
                secondaryDataPopup.classList.remove('zoom-mode', 'fixed-panel');
                
                // Move popup back to body if it's in a chart container
                if (secondaryDataPopup.parentElement !== document.body) {
                    document.body.appendChild(secondaryDataPopup);
                }
                
                if (immediate) {
                    secondaryDataPopup.classList.remove('show');
                    console.log('📊 Secondary data popup hidden immediately');
                } else {
                    // Add hiding animation
                    secondaryDataPopup.classList.add('hiding');
                    setTimeout(() => {
                        secondaryDataPopup.classList.remove('show', 'hiding');
                    }, 300);
                    console.log('📊 Secondary data popup hidden with animation');
                }
            }
            
            function schedulePopupHide(delay = 500) {
                // Don't schedule hide if popup is locked
                if (isPopupLocked) {
                    console.log('📊 Popup hide scheduling prevented - popup is locked');
                    return;
                }
                
                // Don't schedule hide if in fixed panel mode
                if (secondaryDataPopup && secondaryDataPopup.classList.contains('fixed-panel')) {
                    console.log('📊 Popup hide scheduling prevented - fixed panel mode');
                    return;
                }
                
                if (popupHideTimeout) {
                    clearTimeout(popupHideTimeout);
                }
                
                popupHideTimeout = setTimeout(() => {
                    hideSecondaryDataPopup();
                    popupHideTimeout = null;
                }, delay);
            }

            // Load secondary CSV data (big_oi_summary) with fallback search
            async function loadSecondaryData(date) {
                try {
                    const dateStr = date; // e.g., "2025-06-20"
                    const filename = `big_oi_summary_rev2${dateStr}.csv`;
                    
                    // Check cache first
                    if (secondaryDataCache[dateStr]) {
                        console.log(`� Using cached secondary data for ${dateStr}`);
                        return secondaryDataCache[dateStr];
                    }
                    
                    // Define search paths in order of preference
                    const searchPaths = [
                        `./${filename}`,           // Current directory first
                        `summary/${filename}`,     // Summary directory via server route
                        `../summary/${filename}`   // Fallback path
                    ];
                    
                    console.log(`📁 Searching for secondary data file: ${filename}`);
                    console.log(`🔍 Search paths:`, searchPaths);
                    
                    let response = null;
                    let foundPath = null;
                    
                    // Try each path in order
                    for (const path of searchPaths) {
                        try {
                            console.log(`� Trying path: ${path}`);
                            response = await fetch(path);
                            if (response.ok) {
                                foundPath = path;
                                console.log(`✅ Found secondary data at: ${path}`);
                                break;
                            } else {
                                console.log(`❌ Not found at: ${path} (Status: ${response.status})`);
                            }
                        } catch (error) {
                            console.log(`❌ Error accessing: ${path} - ${error.message}`);
                        }
                    }
                    
                    // If not found in any path
                    if (!response || !response.ok) {
                        console.warn(`⚠️ Secondary data file not found in any search path: ${filename}`);
                        
                        // Test server file access for debugging
                        const serverFiles = await testServerFileAccess();
                        if (serverFiles && serverFiles.length > 0) {
                            console.log('📋 Available summary files on server:', serverFiles.map(f => f.name));
                        }
                        
                        return null;
                    }
                    
                    const csvText = await response.text();
                    console.log(`📄 Secondary file loaded successfully from ${foundPath}. Size: ${csvText.length} characters`);
                    
                    // Parse CSV
                    const lines = csvText.split('\n');
                    const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                    
                    console.log(`📋 Secondary CSV Headers found: (${headers.length})`, headers);
                    
                    // Find datetime column
                    const datetimeIndex = headers.findIndex(h => h.includes('datetime') || h.includes('time'));
                    if (datetimeIndex === -1) {
                        console.error('❌ No datetime column found in secondary CSV');
                        return null;
                    }
                    
                    console.log(`📝 Found datetime column at index ${datetimeIndex}: "${headers[datetimeIndex]}"`);
                    
                    // Parse data rows
                    const data = [];
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;
                        
                        const cols = line.split(',');
                        if (cols.length < headers.length) continue;
                        
                        // Create row object
                        const row = {};
                        headers.forEach((header, index) => {
                            row[header] = cols[index] ? cols[index].trim() : '';
                        });
                        
                        data.push(row);
                    }
                    
                    console.log(`📊 Secondary data parsed: ${data.length} rows`);
                    
                    // Cache the data
                    secondaryDataCache[dateStr] = {
                        headers: headers,
                        data: data,
                        datetimeColumn: headers[datetimeIndex],
                        loadedFrom: foundPath
                    };
                    
                    return secondaryDataCache[dateStr];
                    
                } catch (error) {
                    console.error('❌ Error loading secondary data:', error);
                    return null;
                }
            }

            // Filter secondary data by datetime
            function filterSecondaryDataByTime(secondaryData, targetTime) {
                if (!secondaryData || !secondaryData.data) {
                    return [];
                }
                
                const datetimeColumn = secondaryData.datetimeColumn;
                const targetTimeStr = targetTime; // e.g., "2025-06-20 09:34:00"
                
                console.log(`🔍 Filtering secondary data for time: ${targetTimeStr}`);
                console.log(`🔍 Using datetime column: ${datetimeColumn}`);
                console.log(`🔍 Total rows in secondary data: ${secondaryData.data.length}`);
                
                // Check first few rows to see actual datetime format
                const sampleRows = secondaryData.data.slice(0, 3);
                console.log(`🔍 Sample datetime values from CSV:`, sampleRows.map(row => row[datetimeColumn]));
                
                const filteredRows = secondaryData.data.filter(row => {
                    const rowTime = row[datetimeColumn];
                    if (!rowTime) return false;
                    
                    // Try exact match first
                    if (rowTime === targetTimeStr) return true;
                    
                    // Try partial match (contains the time part)
                    // const targetTimePart = targetTimeStr.split(' ')[1]; // e.g., "09:34:00"
                    // if (rowTime.includes(targetTimePart)) {
                    //     console.log(`🎯 Partial match found: ${rowTime} contains ${targetTimePart}`);
                    //     return true;
                    // }
                    
                    return false;
                });
                
                console.log(`📊 Found ${filteredRows.length} matching rows for ${targetTimeStr}`);
                
                if (filteredRows.length > 0) {
                    console.log('📋 Sample matching rows:', filteredRows.slice(0, 2));
                }
                
                return filteredRows;
            }

            // Load CSV data
            async function loadData() {
                try {
                    const config = INDEX_CONFIG[currentIndex];
                    console.log(`📁 Attempting to fetch: ${config.filename}`);

                    const response = await fetch(config.filename);

                    if (!response.ok) {
                        throw new Error(`Failed to fetch ${config.filename}: ${response.status} ${response.statusText}`);
                    }

                    const text = await response.text();
                    console.log(`📄 File loaded successfully. Size: ${text.length} characters`);
                    if (!text.trim()) {
                        throw new Error(`File ${config.filename} is empty`);
                    }

                    const lines = text.trim().split('\n');
                    const data = [];

                    if (lines.length < 2) {
                        throw new Error('CSV file is empty or has no data rows');
                    }

                    // Parse header row to identify column structure
                    const headerRow = lines[0].toLowerCase().trim();
                    const headers = headerRow.split(',').map(h => h.trim());

                    console.log('📋 CSV Headers found:', headers);
                    
                    // SPECIFIC DEBUG FOR OUR TARGET COLUMNS
                    console.log('🚨 DEBUGGING COLUMN DETECTION:');
                    console.log('🚨 Looking for safety_DL in headers...');
                    const safetyDLIndex = headers.findIndex(h => h === 'safety_dl');
                    console.log(`🚨 safety_dl found at index: ${safetyDLIndex}`);
                    
                    console.log('🚨 Looking for trial_DL in headers...');
                    const trialDLIndex = headers.findIndex(h => h === 'trial_dl');
                    console.log(`🚨 trial_dl found at index: ${trialDLIndex}`);
                    
                    console.log('🚨 Headers around indices 60-65:', headers.slice(60, 66));                    // Define column mappings (current and legacy)
                    const currentColumns = {
                        datetime: 'datetime',
                        close: 'close',
                        high: 'high',
                        low: 'low',
                        open: 'open',
                        volume: 'volume',
                        open_interest: 'open_interest',
                        trn_oi: 'trn_oi',
                        sent: 'sent',
                        spurt: 'spurt',
                        time: 'time',
                        trust_value: 'trust_value',
                        direction: 'direction',
                        safety_strk: 'safety_strk',
                        trial_strk: 'trial_strk',
                        safety_entry: 'safety_entry',
                        safety_DL: 'safety_dl',
                        trial_entry: 'trial_entry',
                        trial_DL: 'trial_dl',
                        atm_sent: 'atm_sent',
                        otm_sent: 'otm_sent',
                        anamoly: 'anamoly',
                        fut_oi: 'fut_oi',
                        vol_1m: 'vol_1m',
                        oi_5m_pct_chng: 'oi_5m_pct_chng',
                        up_pct: 'up_pct',
                        down_pct: 'down_pct'
                    }; const legacyColumns = {
                        datetime: 'datetime',
                        close: 'close_x',
                        high: 'high_x',
                        low: 'low_x',
                        open: 'yf_open',
                        volume: 'vol_1m',
                        open_interest: 'open_interest',
                        trn_oi: 'trn_oi',
                        sent: 'sent',
                        spurt: 'spurt',
                        time: 'time',
                        trust_value: 'trust_value',
                        direction: 'direction',
                        safety_strk: 'safety_strk',
                        trial_strk: 'trial_strk',
                        safety_entry: 'safety_entry',
                        safety_DL: 'safety_dl',
                        trial_entry: 'trial_entry',
                        trial_DL: 'trial_dl',
                        atm_sent: 'atm_sent',
                        otm_sent: 'otm_sent',
                        anamoly: 'anamoly',
                        fut_oi: 'fut_oi',
                        vol_1m: 'vol_1m',
                        oi_5m_pct_chng: 'oi_5m_pct_chng',
                        up_pct: 'up_pct',
                        down_pct: 'down_pct'
                    };

                    // Required and optional fields
                    const requiredFields = ['datetime', 'close', 'high', 'low', 'open', 'volume'];
                    const optionalFields = ['open_interest', 'trn_oi', 'sent', 'spurt', 'time', 'trust_value', 'direction', 'safety_strk', 'trial_strk', 'safety_entry', 'safety_DL', 'trial_entry', 'trial_DL', 'atm_sent', 'otm_sent', 'anamoly', 'fut_oi', 'vol_1m', 'oi_5m_pct_chng', 'up_pct', 'down_pct'];

                    // Detect file format by checking for key legacy indicators
                    const isLegacyFormat = headers.includes('close_x') || headers.includes('yf_open') || headers.includes('vol_1m');
                    const columnMapping = isLegacyFormat ? legacyColumns : currentColumns;

                    console.log(`📊 Detected ${isLegacyFormat ? 'LEGACY' : 'CURRENT'} file format`);
                    console.log('🔧 Using column mapping:', columnMapping);

                    // Find column indices using the detected format
                    const columnIndices = {};

                    for (const field of requiredFields) {
                        const columnName = columnMapping[field];
                        const index = headers.findIndex(h => h === columnName);

                        if (index !== -1) {
                            console.log(`📝 Found column "${columnName}" for ${field} at index ${index}`);
                            columnIndices[field] = index;
                        } else {
                            columnIndices[field] = -1;
                        }
                    }

                    // Check required columns
                    for (const field of requiredFields) {
                        if (columnIndices[field] === -1) {
                            const expectedColumn = columnMapping[field];
                            throw new Error(`Required column "${expectedColumn}" not found for ${field} in ${isLegacyFormat ? 'legacy' : 'current'} format. Available columns: ${headers.join(', ')}`);
                        }
                    }
                    console.log('✅ Column mapping successful:', columnIndices);

                    // Find optional columns
                    for (const field of optionalFields) {
                        const columnName = columnMapping[field];
                        const index = headers.findIndex(h => h === columnName);
                        if (index !== -1) {
                            console.log(`📝 Found optional column "${columnName}" for ${field} at index ${index}`);
                            columnIndices[field] = index;
                        } else {
                            console.log(`⚠️ Optional column "${columnName}" for ${field} not found`);
                            columnIndices[field] = -1;
                        }
                    }

                    // Enhanced debugging for sent column specifically
                    console.log(`🚨 SENT COLUMN DEBUG:`);
                    console.log(`   📊 Column mapping for sent: "${columnMapping.sent}"`);
                    console.log(`   🔢 Column index found: ${columnIndices.sent}`);
                    console.log(`   📋 Headers array length: ${headers.length}`);
                    console.log(`   📝 All headers:`, headers);
                    if (columnIndices.sent >= 0) {
                        console.log(`   ✅ Header at sent index ${columnIndices.sent}: "${headers[columnIndices.sent]}"`);
                    }

                    // Debug: Check if our new columns are found
                    console.log('🔍 New column indices:', {
                        safety_entry: columnIndices.safety_entry,
                        safety_DL: columnIndices.safety_DL,
                        trial_entry: columnIndices.trial_entry,
                        trial_DL: columnIndices.trial_DL
                    });
                    
                    // Debug: Check actual header names for our target columns
                    if (columnIndices.safety_entry >= 0) {
                        console.log(`✅ safety_entry found at index ${columnIndices.safety_entry}: "${headers[columnIndices.safety_entry]}"`);
                    }
                    if (columnIndices.safety_DL >= 0) {
                        console.log(`✅ safety_DL found at index ${columnIndices.safety_DL}: "${headers[columnIndices.safety_DL]}"`);
                    }
                    if (columnIndices.trial_entry >= 0) {
                        console.log(`✅ trial_entry found at index ${columnIndices.trial_entry}: "${headers[columnIndices.trial_entry]}"`);
                    }
                    if (columnIndices.trial_DL >= 0) {
                        console.log(`✅ trial_DL found at index ${columnIndices.trial_DL}: "${headers[columnIndices.trial_DL]}"`);
                    }

                    console.log('✅ Column mapping successful:', columnIndices);


                    // Try to find OI columns (optional)
                    const oiColumnIndices = {};
                    const oiHeaders = headers.map(h => h.toLowerCase());                // Find Call_OI column - improved detection
                    console.log('🔍 Looking for Call_OI column in headers:', headers);
                    let callOIIndex = headers.findIndex(h => h === 'Call_OI');
                    if (callOIIndex === -1) {
                        callOIIndex = oiHeaders.findIndex(h => h === 'call_oi');
                    }
                    if (callOIIndex === -1) {
                        callOIIndex = oiHeaders.findIndex(h => h.includes('call_oi'));
                    }

                    if (callOIIndex !== -1) {
                        oiColumnIndices.call_oi = callOIIndex;
                        console.log(`📝 ✅ Found Call_OI column at index ${callOIIndex}: "${headers[callOIIndex]}"`);
                    } else {
                        console.warn('⚠️ Call_OI column not found in headers');
                    }
                    // Find open_interest column - improved detection
                    console.log('🔍 Looking for open_interest column in headers:', headers);
                    let openInterestIndex = headers.findIndex(h => h === 'open_interest');
                    if (openInterestIndex === -1) {
                        openInterestIndex = oiHeaders.findIndex(h => h === 'open_interest');
                    }
                    if (openInterestIndex === -1) {
                        openInterestIndex = oiHeaders.findIndex(h => h.includes('open_interest'));
                    }

                    if (openInterestIndex !== -1) {
                        oiColumnIndices.open_interest = openInterestIndex;
                        console.log(`📝 ✅ Found open_interest column at index ${openInterestIndex}: "${headers[openInterestIndex]}"`);
                    } else {
                        console.warn('⚠️ open_interest column not found in headers');
                    }

                    // Log the exact column names being used
                    console.log('🎯 Using these columns:', {
                        datetime: headers[columnIndices.datetime],
                        open: headers[columnIndices.open],
                        high: headers[columnIndices.high],
                        low: headers[columnIndices.low],
                        close: headers[columnIndices.close],
                        volume: headers[columnIndices.volume],
                        call_oi: oiColumnIndices.call_oi !== undefined ? headers[oiColumnIndices.call_oi] : 'NOT FOUND',
                        open_interest: oiColumnIndices.open_interest !== undefined ? headers[oiColumnIndices.open_interest] : 'NOT FOUND'
                    });// Parse data rows - focus only on required columns
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue; // Skip empty lines

                        // Simple split - we'll validate only required columns
                        const cols = line.split(',');

                        // Extract only the required column values with validation
                        const requiredData = {};
                        let isValidRow = true;

                        for (const field of requiredFields) {
                            const colIndex = columnIndices[field];
                            if (colIndex >= 0 && colIndex < cols.length) {
                                const value = cols[colIndex] ? cols[colIndex].trim() : '';

                                // Validate required fields
                                if (field === 'datetime') {
                                    if (!value || value === '') {
                                        isValidRow = false;
                                        break;
                                    }
                                    requiredData[field] = value;
                                } else if (['open', 'high', 'low', 'close'].includes(field)) {
                                    const numValue = safeParseFloat(value);
                                    if (numValue <= 0) {
                                        isValidRow = false;
                                        break;
                                    }
                                    requiredData[field] = numValue;
                                } else if (field === 'volume') {
                                    const numValue = Math.max(0, safeParseFloat(value, 0));
                                    requiredData[field] = numValue;
                                }
                            } else {
                                isValidRow = false;
                                break;
                            }
                        }
                        // Skip invalid rows
                        if (!isValidRow) {
                            if (data.length < 3) {
                                console.log(`⚠️ Row ${i}: Skipping - invalid or missing required data`);
                            }
                            continue;
                        }
                        // Process valid row
                        try {
                            const dateStr = requiredData.datetime;

                            // Debug: Log first few date strings
                            if (data.length < 3) {
                                console.log(`🔍 Row ${i}: Processing datetime = "${dateStr}"`);
                            }

                            // Parse date format - handle different possible formats
                            let date;
                            if (dateStr.includes(' ')) {
                                const [datePart, timePart] = dateStr.split(' ');
                                let day, month, year;

                                if (datePart.includes('-')) {
                                    const dateParts = datePart.split('-');
                                    if (dateParts[0].length === 4) {
                                        // YYYY-MM-DD format
                                        [year, month, day] = dateParts;
                                    } else {
                                        // DD-MM-YYYY format
                                        [day, month, year] = dateParts;
                                    }
                                }

                                const [hour, minute] = timePart.split(':');
                                const isoDateStr = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}T${hour.padStart(2, '0')}:${minute.padStart(2, '0')}:00`;
                                date = new Date(isoDateStr);
                            } else {
                                // Try parsing as-is
                                date = new Date(dateStr);
                            }
                            if (!isNaN(date.getTime())) {
                                const dataPoint = {
                                    time: Math.floor(date.getTime() / 1000),
                                    open: requiredData.open,
                                    high: requiredData.high,
                                    low: requiredData.low,
                                    close: requiredData.close,
                                    volume: requiredData.volume
                                };

                                // Add trn_oi if available
                                if (columnIndices.trn_oi >= 0 && columnIndices.trn_oi < cols.length) {
                                    const trnOiValue = safeParseFloat(cols[columnIndices.trn_oi]);
                                    dataPoint.trn_oi = trnOiValue;
                                    if (data.length < 3) {
                                        console.log(`✅ trn_oi value ${data.length} ADDED:`, trnOiValue);
                                    }
                                }

                                // Add up_pct if available
                                if (columnIndices.up_pct >= 0 && columnIndices.up_pct < cols.length) {
                                    const upPctValue = safeParseFloat(cols[columnIndices.up_pct]);
                                    dataPoint.up_pct = upPctValue;
                                    if (data.length < 3) {
                                        console.log(`✅ up_pct value ${data.length} ADDED:`, upPctValue);
                                    }
                                }

                                // Add down_pct if available
                                if (columnIndices.down_pct >= 0 && columnIndices.down_pct < cols.length) {
                                    const downPctValue = safeParseFloat(cols[columnIndices.down_pct]);
                                    dataPoint.down_pct = downPctValue;
                                    if (data.length < 3) {
                                        console.log(`✅ down_pct value ${data.length} ADDED:`, downPctValue);
                                    }
                                }

                                // Add sent if available
                                if (columnIndices.sent >= 0 && columnIndices.sent < cols.length) {
                                    const sentValue = safeParseFloat(cols[columnIndices.sent]);
                                    dataPoint.sent = sentValue;
                                    if (data.length < 3) {
                                        console.log(`✅ sent value ${data.length} ADDED:`, sentValue);
                                    }
                                    
                                    // ENHANCED DEBUG FOR PROBLEMATIC TIMES DURING PARSING
                                    if (columnIndices.time >= 0 && columnIndices.time < cols.length) {
                                        const timeValue = cols[columnIndices.time] ? cols[columnIndices.time].trim() : '';
                                        if (['09:18', '09:19', '09:20'].includes(timeValue)) {
                                            console.log(`🚨 CSV PARSING - PROBLEMATIC TIME ${timeValue}:`);
                                            console.log(`   📊 Raw sent column value: "${cols[columnIndices.sent]}"`);
                                            console.log(`   📊 Parsed sent value: ${sentValue} (${typeof sentValue})`);
                                            console.log(`   📊 Is NaN: ${isNaN(sentValue)}`);
                                            console.log(`   📊 Will be added to dataPoint: ${!isNaN(sentValue)}`);
                                            console.log(`   📊 Column index for sent: ${columnIndices.sent}`);
                                            console.log(`   📈 Full row:`, cols);
                                            console.log(`   📍 Final dataPoint.sent: ${dataPoint.sent}`);
                                        }
                                    }
                                }

                                // Add anamoly if available
                                if (columnIndices.anamoly >= 0 && columnIndices.anamoly < cols.length) {
                                    const anamolyValue = safeParseFloat(cols[columnIndices.anamoly]);
                                    dataPoint.anamoly = anamolyValue;
                                    if (data.length < 3) {
                                        console.log(`✅ anamoly value ${data.length} ADDED:`, anamolyValue);
                                    }
                                    
                                    // Debug anamoly for problematic times
                                    if (columnIndices.time >= 0 && columnIndices.time < cols.length) {
                                        const timeValue = cols[columnIndices.time] ? cols[columnIndices.time].trim() : '';
                                        if (['09:18', '09:19', '09:20'].includes(timeValue)) {
                                            console.log(`🚨 CSV PARSING - ${timeValue} ANAMOLY: ${anamolyValue}`);
                                        }
                                    }
                                }

                                // Add spurt if available
                                if (columnIndices.spurt >= 0 && columnIndices.spurt < cols.length) {
                                    const spurtValue = safeParseFloat(cols[columnIndices.spurt]);
                                    dataPoint.spurt = spurtValue;
                                    if (data.length < 3) {
                                        console.log(`✅ spurt value ${data.length} ADDED:`, spurtValue);
                                    }
                                }

                                // Add time string if available
                                if (columnIndices.time >= 0 && columnIndices.time < cols.length) {
                                    const timeValue = cols[columnIndices.time] ? cols[columnIndices.time].trim() : '';
                                    if (timeValue) {
                                        dataPoint.time_str = timeValue;
                                        
                                        // SPECIFIC DEBUG FOR 10:19
                                        if (timeValue === '10:19') {
                                            console.log(`🚨 FOUND 10:19 ROW! Processing columns...`);
                                            console.log(`🚨 Row data:`, cols);
                                            console.log(`🚨 safety_entry index: ${columnIndices.safety_entry}, value: "${cols[columnIndices.safety_entry]}"`);
                                            console.log(`🚨 safety_DL index: ${columnIndices.safety_DL}, value: "${cols[columnIndices.safety_DL]}"`);
                                            console.log(`🚨 trial_entry index: ${columnIndices.trial_entry}, value: "${cols[columnIndices.trial_entry]}"`);
                                            console.log(`🚨 trial_DL index: ${columnIndices.trial_DL}, value: "${cols[columnIndices.trial_DL]}"`);
                                        }
                                        
                                        if (data.length < 3) {
                                            console.log(`✅ time string ${data.length} ADDED:`, timeValue);
                                        }
                                    }
                                }

                                // Add trust_value if available
                                if (columnIndices.trust_value >= 0 && columnIndices.trust_value < cols.length) {
                                    const trustValue = safeParseFloat(cols[columnIndices.trust_value]);
                                    dataPoint.trust_value = trustValue;
                                    if (data.length < 3) {
                                        console.log(`✅ trust_value ${data.length} ADDED:`, trustValue);
                                    }
                                }

                                // Add direction if available
                                if (columnIndices.direction >= 0 && columnIndices.direction < cols.length) {
                                    const directionValue = safeParseFloat(cols[columnIndices.direction]);
                                    dataPoint.direction = directionValue;
                                    if (data.length < 3) {
                                        console.log(`✅ direction ${data.length} ADDED:`, directionValue);
                                    }
                                }

                                // Add safety_strk if available
                                if (columnIndices.safety_strk >= 0 && columnIndices.safety_strk < cols.length) {
                                    const safetyValue = cols[columnIndices.safety_strk] ? cols[columnIndices.safety_strk].trim() : '';
                                    if (safetyValue && safetyValue !== '0' && safetyValue !== '0.0') {
                                        dataPoint.safety_strk = safetyValue;
                                        if (data.length < 3) {
                                            console.log(`✅ safety_strk ${data.length} ADDED:`, safetyValue);
                                        }
                                    }
                                }

                                // Add trial_strk if available
                                if (columnIndices.trial_strk >= 0 && columnIndices.trial_strk < cols.length) {
                                    const trialValue = cols[columnIndices.trial_strk] ? cols[columnIndices.trial_strk].trim() : '';
                                    if (trialValue && trialValue !== '0' && trialValue !== '0.0') {
                                        dataPoint.trial_strk = trialValue;
                                        if (data.length < 3) {
                                            console.log(`✅ trial_strk ${data.length} ADDED:`, trialValue);
                                        }
                                    }
                                }

                                // Add safety_entry if available
                                if (columnIndices.safety_entry >= 0 && columnIndices.safety_entry < cols.length) {
                                    const safetyEntryValue = safeParseFloat(cols[columnIndices.safety_entry]);
                                    dataPoint.safety_entry = safetyEntryValue;
                                    if (data.length < 3) {
                                        console.log(`✅ safety_entry ${data.length} ADDED:`, safetyEntryValue);
                                    }
                                }

                                // Add safety_DL if available
                                if (columnIndices.safety_DL >= 0 && columnIndices.safety_DL < cols.length) {
                                    const safetyDLValue = safeParseFloat(cols[columnIndices.safety_DL]);
                                    if (data.length < 3) {
                                        console.log(`🔍 safety_DL raw value: "${cols[columnIndices.safety_DL]}", parsed: ${safetyDLValue}, isNaN: ${isNaN(safetyDLValue)}`);
                                    }
                                    dataPoint.safety_DL = safetyDLValue;
                                    if (data.length < 3) {
                                        console.log(`✅ safety_DL ${data.length} ADDED:`, safetyDLValue);
                                    }
                                }

                                // Add trial_entry if available
                                if (columnIndices.trial_entry >= 0 && columnIndices.trial_entry < cols.length) {
                                    const trialEntryValue = safeParseFloat(cols[columnIndices.trial_entry]);
                                    dataPoint.trial_entry = trialEntryValue;
                                    if (data.length < 3) {
                                        console.log(`✅ trial_entry ${data.length} ADDED:`, trialEntryValue);
                                    }
                                }

                                // Add trial_DL if available
                                if (columnIndices.trial_DL >= 0 && columnIndices.trial_DL < cols.length) {
                                    const trialDLValue = safeParseFloat(cols[columnIndices.trial_DL]);
                                    if (data.length < 3) {
                                        console.log(`🔍 trial_DL raw value: "${cols[columnIndices.trial_DL]}", parsed: ${trialDLValue}, isNaN: ${isNaN(trialDLValue)}`);
                                    }
                                    dataPoint.trial_DL = trialDLValue;
                                    if (data.length < 3) {
                                        console.log(`✅ trial_DL ${data.length} ADDED:`, trialDLValue);
                                    }
                                }

                                // Add atm_sent if available
                                if (columnIndices.atm_sent >= 0 && columnIndices.atm_sent < cols.length) {
                                    const atmSentValue = safeParseFloat(cols[columnIndices.atm_sent]);
                                    dataPoint.atm_sent = atmSentValue;
                                    if (data.length < 3) {
                                        console.log(`✅ atm_sent ${data.length} ADDED:`, atmSentValue);
                                    }
                                }

                                // Add otm_sent if available
                                if (columnIndices.otm_sent >= 0 && columnIndices.otm_sent < cols.length) {
                                    const otmSentValue = safeParseFloat(cols[columnIndices.otm_sent]);
                                    dataPoint.otm_sent = otmSentValue;
                                    if (data.length < 3) {
                                        console.log(`✅ otm_sent ${data.length} ADDED:`, otmSentValue);
                                    }
                                }

                                // Add anamoly if available
                                if (columnIndices.anamoly >= 0 && columnIndices.anamoly < cols.length) {
                                    const anamolyValue = safeParseFloat(cols[columnIndices.anamoly]);
                                    dataPoint.anamoly = anamolyValue;
                                    if (data.length < 3) {
                                        console.log(`✅ anamoly ${data.length} ADDED:`, anamolyValue);
                                    }
                                }

                                // Add fut_oi if available
                                if (columnIndices.fut_oi >= 0 && columnIndices.fut_oi < cols.length) {
                                    const futOiValue = safeParseFloat(cols[columnIndices.fut_oi]);
                                    dataPoint.fut_oi = futOiValue;
                                    if (data.length < 3) {
                                        console.log(`✅ fut_oi ${data.length} ADDED:`, futOiValue);
                                    }
                                }

                // Add vol_1m if available
                if (columnIndices.vol_1m >= 0 && columnIndices.vol_1m < cols.length) {
                    const vol1mValue = safeParseFloat(cols[columnIndices.vol_1m]);
                    dataPoint.vol_1m = vol1mValue;
                    if (data.length < 5) {
                        console.log(`✅ vol_1m ${data.length} ADDED:`, vol1mValue);
                    }
                }

                // Add oi_5m_pct_chng if available
                if (columnIndices.oi_5m_pct_chng >= 0 && columnIndices.oi_5m_pct_chng < cols.length) {
                    const oi5mPctChngValue = safeParseFloat(cols[columnIndices.oi_5m_pct_chng]);
                    dataPoint.oi_5m_pct_chng = oi5mPctChngValue;
                    if (data.length < 5) {
                        console.log(`✅ oi_5m_pct_chng ${data.length} ADDED:`, oi5mPctChngValue);
                    }
                }

                                // Add OI fields if available
                                if (data.length < 3) {
                                    console.log(`🔍 Row ${i} - OI Column Indices:`, oiColumnIndices);
                                    console.log(`🔍 Row ${i} - Cols length:`, cols.length);
                                    if (oiColumnIndices.call_oi !== undefined) {
                                        console.log(`🔍 Row ${i} - Call_OI raw value:`, cols[oiColumnIndices.call_oi]);
                                    }
                                    if (oiColumnIndices.open_interest !== undefined) {
                                        console.log(`🔍 Row ${i} - Open Interest raw value:`, cols[oiColumnIndices.open_interest]);
                                    }
                                }

                                if (oiColumnIndices.call_oi !== undefined && oiColumnIndices.call_oi < cols.length) {
                                    const callOIValue = safeParseFloat(cols[oiColumnIndices.call_oi]);
                                    if (data.length < 3) {
                                        console.log(`🔍 Call_OI parsed value ${data.length}:`, callOIValue, 'isNaN:', isNaN(callOIValue), 'isValid (>0):', callOIValue > 0, 'isPlaceholder:', callOIValue === -125100);
                                    }
                                    if (callOIValue > 0 && callOIValue !== -125100) { // Filter out placeholder values and zeros
                                        dataPoint.call_oi = callOIValue;
                                        if (data.length < 3) {
                                            console.log(`✅ Call_OI value ${data.length} ADDED:`, callOIValue);
                                        }
                                    }
                                } else {
                                    if (data.length < 3) {
                                        console.log(`❌ Call_OI column not available or out of bounds`);
                                    }
                                } if (oiColumnIndices.open_interest !== undefined && oiColumnIndices.open_interest < cols.length) {
                                    const openInterestValue = safeParseFloat(cols[oiColumnIndices.open_interest]);
                                    if (data.length < 3) {
                                        console.log(`🔍 Open Interest parsed value ${data.length}:`, openInterestValue, 'isNaN:', isNaN(openInterestValue), 'isValid (>0):', openInterestValue > 0, 'isPlaceholder:', openInterestValue === -125100);
                                    }
                                    if (openInterestValue > 0 && openInterestValue !== -125100) { // Filter out invalid values and zeros
                                        dataPoint.open_interest = openInterestValue;
                                        if (data.length < 3) {
                                            console.log(`✅ Open Interest value ${data.length} ADDED:`, openInterestValue);
                                        }
                                    }
                                } else {
                                    if (data.length < 3) {
                                        console.log(`❌ Open Interest column not available or out of bounds`);
                                    }
                                }

                                // Debug: Show final dataPoint before adding
                                if (data.length < 3) {
                                    console.log(`🎯 Final dataPoint ${data.length} before push:`, {
                                        time: dataPoint.time,
                                        ohlc: [dataPoint.open, dataPoint.high, dataPoint.low, dataPoint.close],
                                        volume: dataPoint.volume,
                                        call_oi: dataPoint.call_oi,
                                        open_interest: dataPoint.open_interest
                                    });
                                }

                                data.push(dataPoint);

                                // Debug: Log first few data points
                                if (data.length <= 3) {
                                    console.log(`✅ Row ${i}: Added data point - OHLC=[${dataPoint.open}, ${dataPoint.high}, ${dataPoint.low}, ${dataPoint.close}], Volume=${dataPoint.volume}`);
                                }
                            } else {
                                if (data.length < 3) {
                                    console.log(`❌ Row ${i}: Invalid date - ${dateStr}`);
                                }
                            }
                        } catch (e) {
                            if (data.length < 3) {
                                console.error(`❌ Row ${i}: Error processing -`, e.message);
                            }
                        }
                    }

                    // Sort by time
                    data.sort((a, b) => a.time - b.time);
                    originalData = data;

                    // Find important candles
                    importantCandles = findImportantCandles(data);
                    
                    // Find high volume candles
                    highVolumeCandles = findHighVolumeCandles(data);
                    
                    // Find future OI changes
                    futureOIChanges = findFutureOIChanges(data);

                    // Debug: Test weight calculations on first few candles
                    console.log('🧮 Testing weight calculations:');
                    for (let i = 0; i < Math.min(3, data.length); i++) {
                        const candle = data[i];
                        const weights = calculateWeights(candle);
                        console.log(`Candle ${i}:`, {
                            OHLC: [candle.open, candle.high, candle.low, candle.close],
                            volume: candle.volume,
                            range: safeToFixed(weights.range, 2),
                            body: safeToFixed(weights.body, 2),
                            upperWkPct: safeToFixed(weights.upperWkPct, 1),
                            lowerWkPct: safeToFixed(weights.lowerWkPct, 1),
                            bodyPct: safeToFixed(weights.bodyPct, 1),
                            direction: weights.direction,
                            wgt_price: safeToFixed(weights.wgt_price, 4),
                            wgt_price_vol: safeToFixed(weights.wgt_price_vol, 4)
                        });
                    }

                    // Debug: Log volume statistics
                    const totalVolume = data.reduce((sum, d) => sum + (d.volume || 0), 0);
                    const maxVolume = Math.max(...data.map(d => d.volume || 0));
                    console.log(`✅ Data loaded: ${data.length} records`);
                    console.log(`📊 Volume stats: Total=${totalVolume.toLocaleString()}, Max=${maxVolume.toLocaleString()}`);
                    console.log(`🎯 Important candles: ${importantCandles.length}`);

                    // FINAL CHECK: Verify problematic times are in loaded data
                    console.log(`🔍 FINAL DATA CHECK - Problematic times verification:`);
                    const problematicTimes = ['09:18', '09:19', '09:20'];
                    problematicTimes.forEach(targetTime => {
                        const foundPoint = data.find(point => point.time_str === targetTime);
                        if (foundPoint) {
                            console.log(`✅ ${targetTime} FOUND in loaded data:`, {
                                time: foundPoint.time,
                                time_str: foundPoint.time_str,
                                sent: foundPoint.sent,
                                sentType: typeof foundPoint.sent,
                                hasTimeStr: !!foundPoint.time_str,
                                hasSent: foundPoint.sent !== undefined
                            });
                        } else {
                            console.log(`❌ ${targetTime} NOT FOUND in loaded data`);
                        }
                    });
                    
                    // Also check total data points with sent values
                    const dataWithSent = data.filter(point => point.sent !== undefined);
                    const dataWithNonZeroSent = data.filter(point => point.sent !== undefined && point.sent !== 0);
                    console.log(`📊 Data summary: ${data.length} total, ${dataWithSent.length} with sent values, ${dataWithNonZeroSent.length} with non-zero sent`);

                    // Debug: Show first 10 data points with their times and sent values
                    console.log(`🚨 FIRST 10 DATA POINTS WITH TIMES AND SENT VALUES:`);
                    data.slice(0, 10).forEach((point, index) => {
                        const date = new Date(point.time * 1000);
                        const timeStr = date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                        console.log(`   ${index}: ${timeStr} -> sent=${point.sent} (${typeof point.sent}), anamoly=${point.anamoly}`);
                    });

                    // Final debugging - check if problematic times made it into final data
                    const finalCheckTimes = ['09:18', '09:19', '09:20'];
                    console.log(`🚨 FINAL DATA CHECK - Looking for problematic times...`);
                    
                    finalCheckTimes.forEach(targetTime => {
                        const foundPoint = data.find(point => {
                            if (point.time) {
                                const date = new Date(point.time * 1000);
                                const timeStr = date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                                return timeStr === targetTime;
                            }
                            return false;
                        });
                        
                        if (foundPoint) {
                            console.log(`✅ ${targetTime} FOUND in final data:`, {
                                time: foundPoint.time,
                                sent: foundPoint.sent,
                                sentType: typeof foundPoint.sent,
                                anamoly: foundPoint.anamoly,
                                hasSent: foundPoint.sent !== undefined
                            });
                            // Add visual indicator for debugging
                            if (targetTime === '09:18') {
                                console.log(`🚨 09:18 CRITICAL DEBUG INFO:`, JSON.stringify(foundPoint, null, 2));
                            }
                        } else {
                            console.log(`❌ ${targetTime} NOT FOUND in final data`);
                        }
                    });

                    // Update data date display
                    updateDataDate(data);

                    return data;
                } catch (error) {
                    console.error('Error loading data:', error);
                    throw error;
                }
            }

            // Update data date display
            function updateDataDate(data) {
                // First try to extract date from current filename
                const config = INDEX_CONFIG[currentIndex];
                const filenameDate = extractDateFromFilename(config.filename);

                if (filenameDate) {
                    document.getElementById('data-date').textContent = filenameDate;
                    console.log(`📅 Data date extracted from filename: ${filenameDate}`);
                    return;
                }

                // Fallback to extracting from data timestamps
                if (!data || data.length === 0) {
                    document.getElementById('data-date').textContent = '--';
                    return;
                }

                // Get the date from the first data point
                const firstTimestamp = data[0].time;
                const date = new Date(firstTimestamp * 1000);

                // Format as DD-MON-YYYY
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

                const day = date.getDate().toString().padStart(2, '0');
                const month = months[date.getMonth()];
                const year = date.getFullYear();

                const formattedDate = `${day}-${month}-${year}`;
                document.getElementById('data-date').textContent = formattedDate;

                console.log(`📅 Data date extracted from timestamps: ${formattedDate}`);
            }

            // Update important candles list in sidebar
            function updateImportantCandlesList(data) {
                const listContainer = document.getElementById('important-candles-list');

                // Find important candles in current timeframe
                let importantCandles = [];

                if (currentTimeframe === '1m') {
                    importantCandles = data.filter(candle => {
                        const range = Math.abs(candle.open - candle.close);
                        return range > IMPORTANT_CANDLE_THRESHOLD;
                    });
                } else {
                    // For aggregated timeframes, get important candles from original 1-minute data
                    const firstTime = data[0]?.time || 0;
                    const lastTime = data[data.length - 1]?.time || 0;
                    importantCandles = originalData.filter(candle =>
                        candle.time >= firstTime &&
                        candle.time <= lastTime &&
                        Math.abs(candle.open - candle.close) > IMPORTANT_CANDLE_THRESHOLD
                    );
                }

                if (importantCandles.length === 0) {
                    listContainer.innerHTML = `
                    <div style="color: #6b7280; font-size: 12px; text-align: center; padding: 10px;">
                        No important candles found
                    </div>
                `;
                    updateSectionCount('important-candles', 0);
                    return;
                }

                // Sort by time (most recent first)
                importantCandles.sort((a, b) => b.time - a.time);

                // Create HTML for important candles list
                const candlesHTML = importantCandles.map(candle => {
                    const date = new Date(candle.time * 1000);
                    const timeStr = date.toLocaleTimeString('en-GB', {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false,
                        timeZone: 'Asia/Kolkata'
                    });

                    const bodyValue = candle.close - candle.open;
                    const bodyColor = bodyValue >= 0 ? '#10b981' : '#ef4444';

                    return `
                    <div style="padding: 4px 0; border-bottom: 1px solid rgba(59, 130, 246, 0.1);">
                        <span style="color: #94a3b8; font-size: 11px;">${timeStr}</span>
                        <span style="color: ${bodyColor}; font-weight: bold; margin-left: 8px;">[${safeToFixed(bodyValue, 2)}]</span>
                    </div>
                `;
                }).join('');

                listContainer.innerHTML = candlesHTML;
                updateSectionCount('important-candles', importantCandles.length);
            }

            // Update important volume candles list in sidebar
            function updateImportantVolumeCandlesList(data) {
                const listContainer = document.getElementById('important-volume-candles-list');

                // Always use 1-minute data regardless of selected timeframe
                const volumeCandles = originalData.filter(candle => {
                    const volume = candle.vol_1m || candle.volume || 0; // Use vol_1m preferentially
                    const volMultiple = volume / VOLUME_BASELINE;
                    
                    // Debug logging for specific times
                    if (candle.time_str && ['09:15', '09:18', '09:45', '10:15', '10:18'].includes(candle.time_str)) {
                        console.log(`📈 Volume Debug for ${candle.time_str}:`, {
                            vol_1m: candle.vol_1m,
                            volume: candle.volume,
                            used_volume: volume,
                            baseline: VOLUME_BASELINE,
                            multiple: safeToFixed(volMultiple, 2) + 'x',
                            meetsThreshold: volMultiple > 1.0 ? 'YES' : 'NO'
                        });
                    }
                    
                    return volMultiple > 1.0; // Volume is more than 1.0x the baseline
                });

                console.log(`📈 Found ${volumeCandles.length} high volume candles (>1.0x baseline of ${VOLUME_BASELINE})`);

                if (volumeCandles.length === 0) {
                    listContainer.innerHTML = `
                    <div style="color: #6b7280; font-size: 12px; text-align: center; padding: 10px;">
                        No high volume candles found
                    </div>
                `;
                    updateSectionCount('high-volume-candles', 0);
                    return;
                }

                // Sort by time (most recent first)
                volumeCandles.sort((a, b) => b.time - a.time);

                // Create HTML for volume candles list
                const candlesHTML = volumeCandles.map(candle => {
                    const date = new Date(candle.time * 1000);
                    const timeStr = date.toLocaleTimeString('en-GB', {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false,
                        timeZone: 'Asia/Kolkata'
                    });

                    const spotChange = candle.close - candle.open;
                    const spotColor = spotChange >= 0 ? '#10b981' : '#ef4444';
                    const volume = candle.vol_1m || candle.volume || 0; // Use vol_1m preferentially
                    const volMultiple = safeToFixed(volume / VOLUME_BASELINE, 1);
                    // Format volume with Indian comma notation
                    const actualVolume = Math.round(volume).toLocaleString('en-IN');

                    return `
                    <div style="padding: 4px 0; border-bottom: 1px solid rgba(59, 130, 246, 0.1);">
                        <span style="color: #94a3b8; font-size: 11px;">${timeStr}</span>
                        <span style="color: ${spotColor}; font-weight: bold; margin-left: 8px;">[${spotChange >= 0 ? '+' : ''}${safeToFixed(spotChange, 1)}]</span>
                        <span style="color: #f59e0b; margin-left: 8px;">${volMultiple}x</span>
                        <span style="color: #ffffff; font-weight: bold; margin-left: 8px; font-size: 14px;">${actualVolume}</span>
                    </div>
                `;
                }).join('');

                listContainer.innerHTML = candlesHTML;
                updateSectionCount('high-volume-candles', volumeCandles.length);
            }

            // Update future OI changes list in sidebar
            function updateFutureOIChangesList(data) {
                const listContainer = document.getElementById('future-oi-changes-list');

                // Always use 1-minute data to calculate OI changes using oi_5m_pct_chng column
                const oiChanges = [];
                
                console.log(`🔍 Checking OI changes in ${originalData.length} original data points using oi_5m_pct_chng...`);
                
                for (let i = 0; i < originalData.length; i++) {
                    const current = originalData[i];
                    
                    // Use the pre-calculated oi_5m_pct_chng column
                    if (current.oi_5m_pct_chng !== undefined && current.oi_5m_pct_chng !== null) {
                        const pctChange = parseFloat(current.oi_5m_pct_chng);
                        
                        // Debug logging for specific times
                        if (current.time_str && ['09:30', '09:31', '09:33', '09:34'].includes(current.time_str)) {
                            console.log(`🔍 OI Update Debug for ${current.time_str}:`, {
                                oi_5m_pct_chng: current.oi_5m_pct_chng,
                                pctChange: pctChange.toFixed(3) + '%',
                                fut_oi: current.fut_oi,
                                meetsThreshold: Math.abs(pctChange) > 0.9 ? 'YES' : 'NO'
                            });
                        }
                        
                        if (Math.abs(pctChange) > 0.9) { // Use 0.9% threshold as requested
                            oiChanges.push({
                                ...current,
                                oiChange: current.fut_oi, // Store current OI value
                                oiChangePct: pctChange
                            });
                        }
                    }
                }

                if (oiChanges.length === 0) {
                    listContainer.innerHTML = `
                    <div style="color: #6b7280; font-size: 12px; text-align: center; padding: 10px;">
                        No significant OI changes found
                    </div>
                `;
                    updateSectionCount('future-oi-changes', 0);
                    return;
                }

                // Sort by time (most recent first)
                oiChanges.sort((a, b) => b.time - a.time);

                // Create HTML for OI changes list
                const changesHTML = oiChanges.map(change => {
                    const date = new Date(change.time * 1000);
                    const timeStr = date.toLocaleTimeString('en-GB', {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false,
                        timeZone: 'Asia/Kolkata'
                    });

                    const spotChange = change.close - change.open;
                    const spotColor = spotChange >= 0 ? '#10b981' : '#ef4444';
                    const oiChangeColor = change.oiChangePct >= 0 ? '#10b981' : '#ef4444';                const oiValue = safeToFixed(change.fut_oi / 100000, 1) + 'L'; // Convert to lakhs
                const oiChangePct = (change.oiChangePct >= 0 ? '+' : '') + safeToFixed(change.oiChangePct, 1) + '%';

                return `
                    <div style="padding: 4px 0; border-bottom: 1px solid rgba(59, 130, 246, 0.1);">
                        <span style="color: #94a3b8; font-size: 11px;">${timeStr}</span>
                        <span style="color: ${spotColor}; font-weight: bold; margin-left: 8px;">[${spotChange >= 0 ? '+' : ''}${safeToFixed(spotChange, 1)}]</span>
                        <span style="color: ${oiChangeColor}; font-weight: bold; margin-left: 8px; font-size: 14px;">[${oiChangePct}]</span>
                        <span style="color: #6b7280; margin-left: 8px;">${oiValue}</span>
                    </div>
                `;
                }).join('');

                listContainer.innerHTML = changesHTML;
                updateSectionCount('future-oi-changes', oiChanges.length);
            }        // Update statistics
            function updateStats(data) {
                if (!data || data.length === 0) return;

                const latest = data[data.length - 1];
                const first = data[0];

                // Calculate metrics with timestamps
                const high = Math.max(...data.map(d => d.high));
                const low = Math.min(...data.map(d => d.low));

                // ALWAYS find the timestamps from original 1-minute data, not aggregated data
                let highTime = '--:--';
                let lowTime = '--:--';

                if (originalData && originalData.length > 0) {
                    // Find the actual 1-minute candle that had the high/low values
                    const highCandle = originalData.find(d => d.high === high);
                    const lowCandle = originalData.find(d => d.low === low);

                    highTime = highCandle ? new Date(highCandle.time * 1000).toLocaleTimeString('en-GB', {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    }) : '--:--';

                    lowTime = lowCandle ? new Date(lowCandle.time * 1000).toLocaleTimeString('en-GB', {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    }) : '--:--';
                }

                // Quick debug for the specific issue
                if (isNaN(high) || high === -Infinity || high === Infinity) {
                    console.error('High calculation failed:', {
                        rawHigh: high,
                        highValues: data.map(d => d.high).slice(0, 10),
                        dataCount: data.length
                    });
                }
                const volatility = safeToFixed((high - low) / latest.close * 100, 2);
                const range = high - low;
                // Volume metrics
                const totalVolume = data.reduce((sum, d) => sum + (d.volume || 0), 0);
                const avgVolume = Math.round(totalVolume / data.length);
                // Important candles for current timeframe
                let importantCount = 0;
                if (currentTimeframe === '1m') {
                    importantCount = data.filter(candle => Math.abs(candle.open - candle.close) > IMPORTANT_CANDLE_THRESHOLD).length;
                } else {
                    // For aggregated timeframes, count from original 1-minute data within the period
                    const firstTime = data[0]?.time || 0;
                    const lastTime = data[data.length - 1]?.time || 0;
                    importantCount = originalData.filter(candle =>
                        candle.time >= firstTime &&
                        candle.time <= lastTime &&
                        Math.abs(candle.open - candle.close) > IMPORTANT_CANDLE_THRESHOLD
                    ).length;
                }
                // Technical analysis
                const bullishCandles = data.filter(d => d.close > d.open).length;
                const bearishCandles = data.filter(d => d.close < d.open).length;

                // Support and resistance (simplified)
                const supportLevel = safeToFixed(low * 1.001, 2);
                const resistanceLevel = safeToFixed(high * 0.999, 2);            // Debug: Check if DOM elements exist before updating
                const dayHighEl = document.getElementById('day-high');
                const dayLowEl = document.getElementById('day-low');

                console.log('🔍 DOM elements check:', {
                    dayHighExists: !!dayHighEl,
                    dayLowExists: !!dayLowEl,
                    high: high,
                    low: low,
                    highTime: highTime,
                    lowTime: lowTime
                });

                if (dayHighEl) {
                    dayHighEl.innerHTML = `[${safeToFixed(high, 2)} <span style="color: #94a3b8; font-size: 12px;">@ ${highTime}</span>]`;
                } else {
                    console.error('❌ day-high element not found');
                }

                if (dayLowEl) {
                    dayLowEl.innerHTML = `[${safeToFixed(low, 2)} <span style="color: #94a3b8; font-size: 12px;">@ ${lowTime}</span>]`;
                } else {
                    console.error('❌ day-low element not found');
                }
                document.getElementById('important-candles').textContent = importantCount;
                document.getElementById('high-volume-candles').textContent = highVolumeCandles.length;
                document.getElementById('support-level').textContent = `₹${supportLevel}`;
                document.getElementById('resistance-level').textContent = `₹${resistanceLevel}`; document.getElementById('price-range').textContent = `₹${safeToFixed(range, 2)}`;
                document.getElementById('bullish-count').textContent = bullishCandles;
                document.getElementById('bearish-count').textContent = bearishCandles;

                // Update important candles list
                updateImportantCandlesList(data);
                
                // Update important volume candles list
                updateImportantVolumeCandlesList(data);
                
                // Update future OI changes list
                updateFutureOIChangesList(data);
            }        // Aggregate data for different timeframes
            function aggregateData(data, timeframe) {
                if (timeframe === '1m') {
                    console.log(`📊 Using 1m data directly - ${data.length} candles`);
                    return data;
                }

                const minutes = { '5m': 5, '15m': 15, '30m': 30, '1h': 60 }[timeframe];
                const aggregated = [];

                console.log(`📊 Aggregating to ${timeframe} (${minutes} minutes) from ${data.length} 1m candles`);

                if (!data || data.length === 0) {
                    console.warn('⚠️ No data to aggregate');
                    return [];
                }

                // Group by time intervals
                const intervalSeconds = minutes * 60;
                let currentGroup = [];
                let groupStartTime = null;

                for (let i = 0; i < data.length; i++) {
                    const candle = data[i];

                    // Calculate the start of the interval for this candle
                    const candleTime = candle.time;
                    const intervalStart = Math.floor(candleTime / intervalSeconds) * intervalSeconds;

                    if (groupStartTime === null) {
                        groupStartTime = intervalStart;
                    }

                    // If this candle belongs to the current interval, add it
                    if (intervalStart === groupStartTime) {
                        currentGroup.push(candle);
                    } else {                    // Process the completed group
                        if (currentGroup.length > 0) {
                            const aggregatedPoint = {
                                time: groupStartTime,
                                open: currentGroup[0].open,
                                high: Math.max(...currentGroup.map(d => d.high)),
                                low: Math.min(...currentGroup.map(d => d.low)),
                                close: currentGroup[currentGroup.length - 1].close,
                                volume: currentGroup.reduce((sum, d) => sum + (d.volume || 0), 0)
                            };

                            // Preserve OI fields - use the last value in the group for OI data
                            const lastCandle = currentGroup[currentGroup.length - 1];
                            if (lastCandle.call_oi !== undefined) {
                                aggregatedPoint.call_oi = lastCandle.call_oi;
                            }
                            if (lastCandle.open_interest !== undefined) {
                                aggregatedPoint.open_interest = lastCandle.open_interest;
                            }

                            aggregated.push(aggregatedPoint);
                        }

                        // Start new group
                        currentGroup = [candle];
                        groupStartTime = intervalStart;
                    }
                }
                // Don't forget the last group
                if (currentGroup.length > 0) {
                    const aggregatedPoint = {
                        time: groupStartTime,
                        open: currentGroup[0].open,
                        high: Math.max(...currentGroup.map(d => d.high)),
                        low: Math.min(...currentGroup.map(d => d.low)),
                        close: currentGroup[currentGroup.length - 1].close,
                        volume: currentGroup.reduce((sum, d) => sum + (d.volume || 0), 0)
                    };

                    // Preserve OI fields - use the last value in the group for OI data
                    const lastCandle = currentGroup[currentGroup.length - 1];
                    if (lastCandle.call_oi !== undefined) {
                        aggregatedPoint.call_oi = lastCandle.call_oi;
                    }
                    if (lastCandle.open_interest !== undefined) {
                        aggregatedPoint.open_interest = lastCandle.open_interest;
                    }

                    aggregated.push(aggregatedPoint);
                }

                console.log(`📊 Aggregated to ${aggregated.length} ${timeframe} candles`);
                return aggregated;
            }        // Update chart with data
            function updateChart(data) {
                console.log('🎯 updateChart called with:', data ? data.length : 0, 'points');
                console.log('🎯 candlestickSeries exists:', !!candlestickSeries);
                console.log('🎯 chart exists:', !!chart);

                if (!candlestickSeries || !window.highVolumeSeries) {
                    console.error('❌ Candlestick series not initialized!');
                    return;
                }

                if (!data || data.length === 0) {
                    console.warn('⚠️ No data to display');
                    return;
                }

                console.log('🔍 First 3 data points:', data.slice(0, 3));
                console.log('🔍 Last 3 data points:', data.slice(-3));
                try {
                    // Use the configured volume baseline for high-volume detection
                    const highVolumeThreshold = VOLUME_BASELINE; // Use the configured baseline

                    console.log('📊 Volume stats:', {
                        volumeBaseline: VOLUME_BASELINE,
                        highVolumeThreshold: highVolumeThreshold,
                        totalCandles: data.length,
                        index: currentIndex
                    });

                    // Split data into regular and high-volume candles
                    const regularCandles = [];
                    const highVolumeCandles = [];

                    data.forEach(candle => {
                        if ((candle.volume || 0) > highVolumeThreshold) {
                            highVolumeCandles.push(candle);
                            console.log(`🔥 High volume candle detected: ${new Date(candle.time * 1000).toLocaleTimeString()} - Volume: ${candle.volume?.toLocaleString()}`);
                        } else {
                            regularCandles.push(candle);
                        }
                    });

                    console.log(`📊 Split data: ${regularCandles.length} regular, ${highVolumeCandles.length} high-volume candles`);

                    // Update both series
                    candlestickSeries.setData(regularCandles);
                    window.highVolumeSeries.setData(highVolumeCandles);

                    console.log('✅ Data set on both candlestick series');

                    // Auto-fit the chart to the data
                    if (chart && chart.timeScale) {
                        setTimeout(() => {
                            try {
                                chart.timeScale().fitContent();
                                console.log('✅ Chart auto-fitted successfully');
                            } catch (error) {
                                console.error('❌ Auto-fit failed:', error);
                            }
                        }, 100);
                    }

                    console.log('✅ Chart updated successfully');
                } catch (error) {
                    console.error('❌ Error updating chart:', error);
                }
            }

            // Update Sentiment Chart with trn_oi data - ALWAYS uses 1-minute data
            function updateSentimentChart() {
                console.log('📈 updateSentimentChart called - ALWAYS using 1-minute data');
                console.log('🔍 DEBUG: Using index.html (main file with debugging)');

                if (!sentimentChart || !sentimentSeries) {
                    console.log('⚠️ Sentiment Chart not initialized, skipping update');
                    return;
                }

                // Check if Chart 3 is in zoom mode (exclusive mode)
                const isZoomMode = chartModes['3'] && !chartModes['1'] && !chartModes['2'];
                console.log('📊 Chart 3 zoom mode:', isZoomMode);

                // ALWAYS use originalData (1-minute data) for sentiment chart
                const data = originalData;

                if (!data || data.length === 0) {
                    console.warn('⚠️ No 1-minute data available for sentiment chart');
                    return;
                }

                console.log(`📊 Sentiment Chart using 1-minute data: ${data.length} points`);

                // Prepare data for sentiment chart (trn_oi line)
                const sentimentData = [];
                
                // Create synchronized time base for all three series
                const timeBase = [];
                data.forEach(point => {
                    // Include all time points that have ANY of the three data types
                    if ((point.trn_oi !== undefined && !isNaN(point.trn_oi)) ||
                        (point.sent !== undefined && !isNaN(point.sent)) ||
                        (point.spurt !== undefined && !isNaN(point.spurt))) {
                        timeBase.push(Math.floor(point.time / 60) * 60); // Normalize to minute boundary
                        
                        // Always add trn_oi data point for the trending line
                        if (point.trn_oi !== undefined && !isNaN(point.trn_oi)) {
                            sentimentData.push({
                                time: Math.floor(point.time / 60) * 60, // Normalize to minute boundary
                                value: point.trn_oi
                            });
                        }
                    }
                });
                
                // Remove duplicates and sort time base
                const uniqueTimeBase = [...new Set(timeBase)].sort((a, b) => a - b);
                console.log(`📊 Synchronized time base created: ${uniqueTimeBase.length} time points`);
                console.log(`📊 Sentiment data prepared: ${sentimentData.length} points`);

                if (sentimentData.length === 0) {
                    console.warn('⚠️ No valid sentiment data found');
                    return;
                }

                // Update series data for trn_oi line
                try {
                    sentimentSeries.setData(sentimentData);
                    console.log('✅ Sentiment line data updated');

                    // Handle bar chart for 'sent' column only in zoom mode
                    if (isZoomMode) {
                        console.log('📊 Adding sent bar chart for zoom mode...');
                        
                        // Create bar series if it doesn't exist
                        if (!sentimentBarSeries) {
                            sentimentBarSeries = sentimentChart.addHistogramSeries({
                                color: '#10b981', // Default green color
                                priceFormat: {
                                    type: 'price',
                                    precision: 2,
                                    minMove: 0.01,
                                },
                                priceScaleId: 'sentiment-bars', // Use separate scale for bars
                                scaleMargins: {
                                    top: 0.5, // Middle 25% (from 50% to 75%)
                                    bottom: 0.25,
                                },
                                base: 0, // Set base line at 0
                            });
                            
                            // Configure the separate price scale for bars
                            sentimentChart.priceScale('sentiment-bars').applyOptions({
                                scaleMargins: {
                                    top: 0.5,
                                    bottom: 0.25,
                                },
                                borderVisible: true,
                                borderColor: '#444',
                                textColor: '#888',
                            });
                            
                            // Add zero reference line for sentiment bars
                            sentimentZeroLine = sentimentChart.addLineSeries({
                                color: '#666666',
                                lineWidth: 1,
                                lineStyle: 1, // Dashed line
                                priceScaleId: 'sentiment-bars',
                                lastValueVisible: false,
                                priceLineVisible: false,
                            });
                            
                            // Set zero line data (horizontal line at 0) using synchronized time base
                            const sentimentZeroData = uniqueTimeBase.map(timePoint => ({
                                time: timePoint, // timePoint is already normalized
                                value: 0
                            }));
                            sentimentZeroLine.setData(sentimentZeroData);
                            
                            // Add custom tooltip for sentiment bars
                            const toolTipWidth = 200;
                            const toolTipHeight = 80;
                            const toolTipMargin = 15;
                            
                            // Create tooltip element
                            const toolTip = document.createElement('div');
                            toolTip.style.width = toolTipWidth + 'px';
                            toolTip.style.height = toolTipHeight + 'px';
                            toolTip.style.position = 'absolute';
                            toolTip.style.display = 'none';
                            toolTip.style.padding = '8px';
                            toolTip.style.boxSizing = 'border-box';
                            toolTip.style.fontSize = '12px';
                            toolTip.style.textAlign = 'left';
                            toolTip.style.zIndex = '1000';
                            toolTip.style.top = '12px';
                            toolTip.style.left = '12px';
                            toolTip.style.pointerEvents = 'none';
                            toolTip.style.border = '1px solid #2962FF';
                            toolTip.style.borderRadius = '4px';
                            toolTip.style.background = 'rgba(25, 32, 45, 0.9)';
                            toolTip.style.color = 'white';
                            toolTip.style.backdropFilter = 'blur(8px)';
                            document.getElementById('sentiment-chart').appendChild(toolTip);
                            
                            // Simpler tooltip approach using mouse events
                            const chartContainer = document.getElementById('sentiment-chart');
                            
                            // Store reference to the chart container for mouse events
                            let isMouseOverChart = false;
                            
                            chartContainer.addEventListener('mouseenter', () => {
                                isMouseOverChart = true;
                            });
                            
                            chartContainer.addEventListener('mouseleave', () => {
                                isMouseOverChart = false;
                                toolTip.style.display = 'none';
                                
                                // Hide secondary data popup when mouse leaves chart
                                schedulePopupHide(300);
                            });
                            
                            chartContainer.addEventListener('mousemove', async (e) => {
                                if (!isMouseOverChart) return;
                                
                                const rect = chartContainer.getBoundingClientRect();
                                const x = e.clientX - rect.left;
                                const y = e.clientY - rect.top;
                                
                                // Get the coordinate from the chart
                                const coordinate = sentimentChart.timeScale().coordinateToTime(x);
                                if (coordinate) {
                                    let tooltipShown = false;
                                    let sentValue = null;
                                    let spurtValue = null;
                                    let timeStr = '';
                                    let fullDateTime = '';
                                    let secondaryDataRows = [];
                                    
                                    // Get the exact time coordinate under the mouse
                                    const mouseTime = coordinate;
                                    if (!mouseTime) return;
                                    
                                    // Truncate to exact minute boundary (no rounding tolerance)
                                    const minuteTime = Math.floor(mouseTime / 60) * 60;
                                    
                                    console.log(`🔍 Mouse Debug: coordinate=${mouseTime}, minuteTime=${minuteTime}`);
                                    
                                    // Convert to time string for display
                                    const displayDate = new Date(minuteTime * 1000);
                                    const currentTimeStr = displayDate.toLocaleTimeString('en-US', { 
                                        hour12: false, 
                                        hour: '2-digit', 
                                        minute: '2-digit' 
                                    });
                                    
                                    console.log(`🔍 Looking for tooltip data at ${currentTimeStr} (timestamp: ${minuteTime})`);
                                    
                                    // ALWAYS find the main data point for this exact time
                                    const exactTimestamp = Math.floor(mouseTime / 60) * 60;
                                    const mainDataPoint = originalData.find(point => {
                                        const pointMinuteTime = Math.floor(point.time / 60) * 60;
                                        return pointMinuteTime === exactTimestamp;
                                    });
                                    
                                    console.log(`🔍 Main data point found:`, mainDataPoint ? `trn_oi=${mainDataPoint.trn_oi}, sent=${mainDataPoint.sent}, spurt=${mainDataPoint.spurt}` : 'NOT FOUND');
                                    
                                    // ALWAYS get all three values from the main data point
                                    let trnOiValue = null;
                                    
                                    if (mainDataPoint) {
                                        // Extract trn_oi value
                                        trnOiValue = mainDataPoint.trn_oi !== undefined ? parseFloat(mainDataPoint.trn_oi || 0) : null;
                                        
                                        // Extract sent value
                                        sentValue = mainDataPoint.sent !== undefined ? parseFloat(mainDataPoint.sent || 0) : null;
                                        
                                        // Extract spurt value
                                        spurtValue = mainDataPoint.spurt !== undefined ? parseFloat(mainDataPoint.spurt || 0) : null;
                                        
                                        timeStr = currentTimeStr;
                                        
                                        console.log(`🔍 Extracted values: trn_oi=${trnOiValue}, sent=${sentValue}, spurt=${spurtValue}`);
                                    }
                                    
                                    // Show popup only if there's a signal value (non-zero) - keep existing popup logic
                                    if (sentValue !== null && sentValue !== 0) {
                                        console.log(`🔍 CONSISTENCY FIX: Using timestamp=${exactTimestamp} for both bar and popup`);
                                        console.log(`🔍 Main data point found:`, mainDataPoint ? `sent=${mainDataPoint.sent}, spurt=${mainDataPoint.spurt}` : 'NOT FOUND');
                                        
                                        // Format full datetime for secondary data search using global currentDate
                                        // Parse currentDate (e.g., "2025-07-03") to get date components
                                        let dateForSearch = currentDate;
                                        
                                        // If currentDate is null or undefined, try to get it from the date picker
                                        if (!dateForSearch) {
                                            const datePicker = document.getElementById('date-select');
                                            if (datePicker && datePicker.value) {
                                                dateForSearch = datePicker.value;
                                                console.log(`🔍 Using date picker value as fallback: ${dateForSearch}`);
                                            } else {
                                                console.error(`❌ Both currentDate and date picker are null/empty - using current system date`);
                                                const today = new Date();
                                                const day = String(today.getDate()).padStart(2, '0');
                                                const month = String(today.getMonth() + 1).padStart(2, '0');
                                                const year = today.getFullYear();
                                                dateForSearch = `${year}-${month}-${day}`;
                                            }
                                        }
                                        
                                        const [year, month, day] = dateForSearch.split('-');
                                        
                                        // Try multiple datetime formats to match CSV data
                                        const fullDateTime1 = `${day}-${month}-${year} ${timeStr}:00`; // 03-07-2025 09:45:00
                                        const fullDateTime2 = `${year}-${month}-${day} ${timeStr}:00`; // 2025-07-03 09:45:00
                                        
                                        console.log(`🔍 Signal found at exact time ${timeStr} (normalized: ${minuteTime})`);
                                        console.log(`🔍 Using dateForSearch: ${dateForSearch} (from ${dateForSearch === currentDate ? 'global currentDate' : 'date picker fallback'})`);
                                        console.log(`🔍 Searching for datetime formats:`);
                                        console.log(`🔍   Format 1: ${fullDateTime1}`);
                                        console.log(`🔍   Format 2: ${fullDateTime2}`);
                                        
                                        fullDateTime = fullDateTime2; // Use format that matches CSV
                                        
                                        // Load secondary data if hovering over a signal bar
                                        // Use the dateForSearch variable (which includes fallback logic)
                                        console.log(`🔍 Current date for secondary data: ${dateForSearch}`);
                                        console.log(`🔍 dateForSearch type: ${typeof dateForSearch}`);
                                        console.log(`🔍 dateForSearch value: "${dateForSearch}"`);
                                        
                                        if (!dateForSearch) {
                                            console.warn('⚠️ dateForSearch is not set - aborting secondary data load');
                                            return;
                                        }
                                        
                                        try {
                                            console.log(`🔍 Loading secondary data for popup...`);
                                            console.log(`🔍 Date for secondary data: "${dateForSearch}"`);
                                            const secondaryData = await loadSecondaryData(dateForSearch);
                                            if (secondaryData) {
                                                console.log(`✅ Secondary data loaded successfully - ${secondaryData.length} rows`);
                                                secondaryDataRows = filterSecondaryDataByTime(secondaryData, fullDateTime);
                                                console.log(`🎯 POPUP DEBUG: Filtered ${secondaryDataRows.length} rows for time ${fullDateTime}`);
                                                
                                                console.log(`🔍 Using consistent main data point found earlier`);
                                                
                                                console.log(`🔍 About to show popup with ${secondaryDataRows.length} rows`);
                                                // Show secondary data popup with main data (using consistent data point)
                                                showSecondaryDataPopup(timeStr, fullDateTime, secondaryDataRows, mainDataPoint);
                                            } else {
                                                console.error(`❌ No secondary data returned for ${dateForSearch}`);
                                                console.error(`❌ dateForSearch type: ${typeof dateForSearch}, value: "${dateForSearch}"`);
                                            }
                                        } catch (error) {
                                            console.error('❌ Error loading secondary data on hover:', error);
                                        }
                                    }
                                    
                                    // NEW: ALWAYS show combined tooltip with all three values if we have any data
                                    if (mainDataPoint && (trnOiValue !== null || sentValue !== null || spurtValue !== null)) {
                                        console.log(`🎯 SHOWING ENHANCED TOOLTIP: Time=${timeStr}, trn_oi=${trnOiValue}, Signal=${sentValue}, Spurt=${spurtValue}`);
                                        
                                        let tooltipContent = `<div style="color: #888; margin-bottom: 4px;">Time: ${timeStr}</div>`;
                                        
                                        // Always show trn_oi if available
                                        if (trnOiValue !== null) {
                                            const trnOiColor = trnOiValue >= 0 ? '#10b981' : '#ef4444';
                                            const trnOiFormatted = formatCompactNumber(trnOiValue);
                                            tooltipContent += `<div>trn_oi: <span style="color: ${trnOiColor}; font-weight: bold;">${trnOiFormatted}</span></div>`;
                                        }
                                        
                                        // Always show signal if available
                                        if (sentValue !== null) {
                                            const sentColor = sentValue >= 0 ? '#10b981' : '#ef4444';
                                            const sentFormatted = safeToFixed(sentValue, 2);
                                            tooltipContent += `<div>Signal: <span style="color: ${sentColor}; font-weight: bold;">${sentFormatted}</span></div>`;
                                        }
                                        
                                        // Always show spurt if available
                                        if (spurtValue !== null) {
                                            const spurtColor = spurtValue >= 0 ? '#10b981' : '#ef4444';
                                            const spurtFormatted = safeToFixed(spurtValue, 2);
                                            tooltipContent += `<div>Spurt: <span style="color: ${spurtColor}; font-weight: bold;">${spurtFormatted}</span></div>`;
                                        }
                                        
                                        // Add hint about secondary data popup if available
                                        if (secondaryDataRows && secondaryDataRows.length > 0) {
                                            tooltipContent += `<div style="border-top: 1px solid #666; margin-top: 4px; padding-top: 4px; font-size: 10px; color: #4ade80;">📊 ${secondaryDataRows.length} options rows → See popup</div>`;
                                        }
                                        
                                        toolTip.innerHTML = tooltipContent;
                                        
                                        let left = x + toolTipMargin;
                                        if (left > rect.width - toolTipWidth) {
                                            left = x - toolTipMargin - toolTipWidth;
                                        }
                                        
                                        let top = y + toolTipMargin;
                                        if (top > rect.height - toolTipHeight) {
                                            top = y - toolTipHeight - toolTipMargin;
                                        }
                                        
                                        toolTip.style.left = left + 'px';
                                        toolTip.style.top = top + 'px';
                                        toolTip.style.display = 'block';
                                        
                                        tooltipShown = true;
                                    }
                                        
                                        let top = y + toolTipMargin;
                                        if (top > rect.height - toolTipHeight) {
                                            top = y - toolTipHeight - toolTipMargin;
                                        }
                                        
                                        toolTip.style.left = left + 'px';
                                        toolTip.style.top = top + 'px';
                                        toolTip.style.display = 'block';
                                    
                                    if (!tooltipShown) {
                                        console.log(`❌ No tooltip shown for ${currentTimeStr} (${minuteTime}) - no data found for this time`);
                                        toolTip.style.display = 'none';
                                        // Also schedule popup hide when no tooltip is shown
                                        schedulePopupHide(200);
                                    }
                                } else {
                                    toolTip.style.display = 'none';
                                }
                            });
                            
                            // Alternative approach: Use chart options for custom tooltip
                            sentimentChart.applyOptions({
                                handleScroll: {
                                    mouseWheel: true,
                                    pressedMouseMove: true,
                                },
                                handleScale: {
                                    axisPressedMouseMove: true,
                                    mouseWheel: true,
                                    pinch: true,
                                },
                                crosshair: {
                                    mode: 0, // Normal crosshair mode
                                },
                                localization: {
                                    priceFormatter: (price) => {
                                        // This will format the price on the y-axis
                                        return safeToFixed(price, 2);
                                    },
                                },
                            });
                            
                            console.log('✅ Sentiment bar series created with separate scale and custom tooltip');
                        }

                        // Create spurt bar series if it doesn't exist
                        if (!spurtBarSeries) {
                            spurtBarSeries = sentimentChart.addHistogramSeries({
                                color: '#10b981', // Default green color
                                priceFormat: {
                                    type: 'price',
                                    precision: 2,
                                    minMove: 0.01,
                                },
                                priceScaleId: 'spurt-bars', // Use separate scale for spurt bars
                                scaleMargins: {
                                    top: 0.75, // Bottom 25% (from 75% to 100%)
                                    bottom: 0.0,
                                },
                                base: 0, // Set base line at 0
                                baseLineVisible: false, // Disable built-in baseline, we'll add our own
                            });
                            
                            // Configure the separate price scale for spurt bars with forced range
                            const spurtValues = data.map(point => point.spurt ? parseFloat(point.spurt) : 0)
                                .filter(val => !isNaN(val) && val !== 0);
                            
                            const maxSpurt = Math.max(...spurtValues);
                            const minSpurt = Math.min(...spurtValues, 0);
                            
                            console.log(`📊 Spurt range detected: min=${minSpurt}, max=${maxSpurt}`);
                            
                            sentimentChart.priceScale('spurt-bars').applyOptions({
                                scaleMargins: {
                                    top: 0.75,
                                    bottom: 0.0,
                                },
                                borderVisible: true,
                                borderColor: '#666',
                                textColor: '#999',
                                autoScale: false, // Disable auto-scale to prevent conflicts
                                mode: 0, // Normal mode
                                invertScale: false,
                                alignLabels: true,
                                entireTextOnly: false,
                            });
                            
                            console.log(`📊 Spurt range configured: min=${minSpurt}, max=${maxSpurt}`);
                            
                            // Add zero reference line for spurt bars
                            spurtZeroLine = sentimentChart.addLineSeries({
                                color: '#555555',
                                lineWidth: 1,
                                lineStyle: 1, // Dashed line
                                priceScaleId: 'spurt-bars',
                                lastValueVisible: false,
                                priceLineVisible: false,
                            });
                            
                            // Set zero line data (horizontal line at 0) using synchronized time base
                            const spurtZeroData = uniqueTimeBase.map(timePoint => ({
                                time: timePoint, // timePoint is already normalized
                                value: 0
                            }));
                            spurtZeroLine.setData(spurtZeroData);
                            
                            console.log('✅ Spurt bar series created with separate scale');
                        }

                        // Prepare bar data from 'sent' column using synchronized time base
                        const barData = [];
                        let sentCount = 0;
                        
                        // Use the synchronized time base to ensure alignment
                        uniqueTimeBase.forEach(normalizedTimePoint => {
                            const point = data.find(d => Math.floor(d.time / 60) * 60 === normalizedTimePoint);
                            if (point && point.sent !== undefined && !isNaN(point.sent)) {
                                const sentValue = parseFloat(point.sent);
                                
                                // Enhanced debug logging for specific problematic times and general range
                                const date = new Date(normalizedTimePoint * 1000);
                                const timeStr = date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                                
                                // Specific debugging for 09:18, 09:19, 09:20
                                const isProblematicTime = ['09:18', '09:19', '09:20'].includes(timeStr);
                                if (isProblematicTime) {
                                    const debugMsg = `🚨 PROBLEMATIC TIME ${timeStr} FOUND:\n` +
                                                   `   📊 sent=${sentValue} (${typeof sentValue})\n` +
                                                   `   🔢 sentValue !== 0: ${sentValue !== 0}\n` +
                                                   `   📈 point.sent: ${point.sent} (${typeof point.sent})\n` +
                                                   `   ⚠️ anamoly: ${point.anamoly}\n` +
                                                   `   ✅ Will add to barData: ${sentValue !== 0}\n` +
                                                   `   🕐 Unix timestamp: ${point.time}\n` +
                                                   `   📅 Full datetime: ${date}`;
                                    
                                    debugLog(debugMsg, true); // Show as alert for critical debugging
                                }
                                
                                // General debug logging for broader time range
                                if (timeStr >= '09:15' && timeStr <= '10:30') {
                                    console.log(`📊 Signal Debug ${timeStr}: sent=${sentValue}, anamoly=${point.anamoly}, will add=${sentValue !== 0}`);
                                }
                                
                                if (sentValue !== 0) { // Only add non-zero values
                                    // Determine color: orange if anamoly=1, otherwise green/red based on sent value
                                    let barColor;
                                    if (point.anamoly === 1) {
                                        barColor = '#f59e0b'; // Orange for anamoly
                                        if (timeStr >= '09:45' && timeStr <= '10:25') {
                                            console.log(`🟠 ANAMOLY detected at ${timeStr}: using orange color`);
                                        }
                                    } else {
                                        barColor = sentValue >= 0 ? '#10b981' : '#ef4444'; // Green for positive, red for negative
                                    }
                                    
                                    const barItem = {
                                        time: Math.floor(point.time / 60) * 60, // Normalize to minute boundary
                                        value: sentValue, // Use actual value (positive/negative)
                                        color: barColor
                                    };
                                    
                                    barData.push(barItem);
                                    sentCount++;
                                    
                                    // Enhanced logging for problematic times
                                    if (isProblematicTime) {
                                        const successMsg = `✅ SUCCESSFULLY ADDED ${timeStr} to barData:\n` +
                                                         `   📊 Time: ${point.time}\n` +
                                                         `   💎 Value: ${sentValue}\n` +
                                                         `   🎨 Color: ${barColor}\n` +
                                                         `   📋 Total bars: ${barData.length}`;
                                        
                                        debugLog(successMsg, true); // Show as alert for verification
                                    }
                                } else {
                                    // Log when bars are NOT added (zero values)
                                    if (isProblematicTime) {
                                        const errorMsg = `❌ NOT ADDED ${timeStr} - sentValue is zero: ${sentValue}`;
                                        debugLog(errorMsg, true); // Show as alert for debugging
                                    }
                                }
                            }
                        });

                        // Sort signal data by time to ensure proper rendering
                        barData.sort((a, b) => a.time - b.time);

                        // Store bar data globally for tooltip access
                        window.sentimentBarData = barData;

                        // Enhanced debugging for problematic times in final barData
                        console.log(`🔍 FINAL BARDATA ANALYSIS:`);
                        console.log(`   📊 Total bars in barData: ${barData.length}`);
                        
                        const problematicTimes = ['09:18', '09:19', '09:20'];
                        problematicTimes.forEach(targetTime => {
                            const foundBar = barData.find(bar => {
                                const barDate = new Date(bar.time * 1000);
                                const barTimeStr = barDate.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                                return barTimeStr === targetTime;
                            });
                            
                            if (foundBar) {
                                console.log(`✅ ${targetTime} FOUND in final barData:`, foundBar);
                            } else {
                                console.log(`❌ ${targetTime} NOT FOUND in final barData`);
                                
                                // Double-check in original data
                                const originalPoint = data.find(point => {
                                    const pointDate = new Date(point.time * 1000);
                                    const pointTimeStr = pointDate.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                                    return pointTimeStr === targetTime;
                                });
                                
                                if (originalPoint) {
                                    console.log(`🔍 ${targetTime} original data point:`, {
                                        time: originalPoint.time,
                                        sent: originalPoint.sent,
                                        sentType: typeof originalPoint.sent,
                                        sentParsed: parseFloat(originalPoint.sent),
                                        sentIsNaN: isNaN(parseFloat(originalPoint.sent))
                                    });
                                } else {
                                    console.log(`⚠️ ${targetTime} not found in original data at all!`);
                                }
                            }
                        });

                        // Log anamoly statistics
                        const anamolyBars = barData.filter(bar => bar.color === '#f59e0b');
                        const normalBars = barData.filter(bar => bar.color !== '#f59e0b');
                        console.log(`📊 Signal Bar Statistics:`);
                        console.log(`   🟠 Anamoly bars (orange): ${anamolyBars.length}`);
                        console.log(`   🟢🔴 Normal bars (green/red): ${normalBars.length}`);
                        console.log(`   📈 Total signal bars: ${barData.length}`);
                        
                        // Specifically check for 10:19 anamoly
                        const tenNineteenBar = barData.find(bar => {
                            const date = new Date(bar.time * 1000);
                            const timeStr = date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                            return timeStr === '10:19';
                        });
                        if (tenNineteenBar) {
                            console.log(`🎯 Found 10:19 bar:`, tenNineteenBar);
                            console.log(`🎯 10:19 bar color: ${tenNineteenBar.color} ${tenNineteenBar.color === '#f59e0b' ? '(ORANGE - ANAMOLY!)' : '(Normal)'}`);
                        } else {
                            console.log(`⚠️ No 10:19 signal bar found in data`);
                        }

                        console.log(`📊 Found ${sentCount} non-zero sent values out of ${data.length} total points`);
                        if (barData.length > 0) {
                            console.log('📊 Sample bar data:', barData.slice(0, 5));
                            
                            // Debug: Show data around 09:48-09:52 specifically
                            const debugBarData = barData.filter(point => {
                                const date = new Date(point.time * 1000);
                                const timeStr = date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                                return timeStr >= '09:45' && timeStr <= '09:55';
                            });
                            if (debugBarData.length > 0) {
                                console.log('🔍 Signal data in 09:45-09:55 range being added to chart:', debugBarData);
                            }
                            
                            sentimentBarSeries.setData(barData);
                            console.log(`✅ Sentiment bar data updated: ${barData.length} points`);
                            
                            // CRITICAL DEBUG: Check chart time scale and visible range
                            if (sentimentChart && sentimentChart.timeScale) {
                                try {
                                    const timeScale = sentimentChart.timeScale();
                                    const visibleRange = timeScale.getVisibleRange();
                                    console.log(`📊 Chart visible time range:`, {
                                        from: visibleRange ? new Date(visibleRange.from * 1000) : 'undefined',
                                        to: visibleRange ? new Date(visibleRange.to * 1000) : 'undefined'
                                    });
                                    
                                    // Check if our problematic times fall within visible range
                                    const problematicTimeStamps = ['09:18', '09:19', '09:20'].map(timeStr => {
                                        const found = barData.find(bar => {
                                            const barDate = new Date(bar.time * 1000);
                                            const barTimeStr = barDate.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                                            return barTimeStr === timeStr;
                                        });
                                        return found ? found.time : null;
                                    }).filter(Boolean);
                                    
                                    if (visibleRange && problematicTimeStamps.length > 0) {
                                        const inVisibleRange = problematicTimeStamps.filter(timestamp => 
                                            timestamp >= visibleRange.from && timestamp <= visibleRange.to
                                        );
                                        
                                        const rangeMsg = `🎯 CRITICAL: Problematic times visibility:\n` +
                                                       `   📊 Total problematic timestamps: ${problematicTimeStamps.length}\n` +
                                                       `   👁️ In visible range: ${inVisibleRange.length}\n` +
                                                       `   📈 Visible range: ${new Date(visibleRange.from * 1000).toLocaleTimeString()} - ${new Date(visibleRange.to * 1000).toLocaleTimeString()}`;
                                        
                                        debugLog(rangeMsg, true);
                                    }
                                } catch (error) {
                                    console.error('Error checking chart time scale:', error);
                                }
                            }
                            
                            // Final verification: Check if problematic times made it to the chart
                            const problematicTimesInChart = ['09:18', '09:19', '09:20'].map(targetTime => {
                                const foundInChart = barData.find(bar => {
                                    const barDate = new Date(bar.time * 1000);
                                    const barTimeStr = barDate.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                                    return barTimeStr === targetTime;
                                });
                                return { time: targetTime, inChart: !!foundInChart, data: foundInChart };
                            });
                            
                            console.log(`🎯 PROBLEMATIC TIMES IN CHART:`, problematicTimesInChart);
                            
                            // Log chart series info
                            console.log(`📈 Chart series type:`, sentimentBarSeries);
                            console.log(`📊 Chart visible range and scale info available for troubleshooting`);
                            
                        } else {
                            console.warn('⚠️ No valid sent data found for bar chart');
                        }

                        // Prepare spurt bar data from 'spurt' column using synchronized time base
                        const spurtData = [];
                        let spurtCount = 0;
                        
                        // Use the synchronized time base to ensure alignment
                        uniqueTimeBase.forEach(normalizedTimePoint => {
                            const point = data.find(d => Math.floor(d.time / 60) * 60 === normalizedTimePoint);
                            if (point && point.spurt !== undefined && !isNaN(point.spurt)) {
                                const spurtValue = parseFloat(point.spurt);
                                
                                // Debug logging for time range around 09:48-09:52
                                const date = new Date(normalizedTimePoint * 1000);
                                const timeStr = date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                                if (timeStr >= '09:45' && timeStr <= '09:55') {
                                    console.log(`🔍 Spurt Debug ${timeStr}: spurt=${spurtValue}, will add=${spurtValue !== 0}`);
                                }
                                
                                if (spurtValue !== 0) { // Only add non-zero values
                                    spurtData.push({
                                        time: Math.floor(point.time / 60) * 60, // Normalize to minute boundary
                                        value: spurtValue, // Use actual value (positive/negative)
                                        color: spurtValue >= 0 ? '#10b981' : '#ef4444' // Green for positive, red for negative
                                    });
                                    spurtCount++;
                                }
                            }
                        });

                        // Sort spurt data by time to ensure proper rendering
                        spurtData.sort((a, b) => a.time - b.time);

                        // Store spurt data globally for tooltip access
                        window.spurtBarData = spurtData;

                        console.log(`📊 Found ${spurtCount} non-zero spurt values out of ${data.length} total points`);
                        if (spurtData.length > 0) {
                            console.log('📊 Sample spurt data:', spurtData.slice(0, 5));
                            
                            // Debug: Show data around 09:48-09:52 specifically
                            const debugSpurtData = spurtData.filter(point => {
                                const date = new Date(point.time * 1000);
                                const timeStr = date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                                return timeStr >= '09:45' && timeStr <= '09:55';
                            });
                            if (debugSpurtData.length > 0) {
                                console.log('🔍 Spurt data in 09:45-09:55 range being added to chart:', debugSpurtData);
                                // Show specific values for 09:48 comparison
                                debugSpurtData.forEach((point, index) => {
                                    const date = new Date(point.time * 1000);
                                    const timeStr = date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                                    console.log(`🎯 Spurt Bar ${timeStr}: value=${point.value}, color=${point.color}, index=${index}`);
                                    
                                    // Special attention to 09:48 vs others
                                    if (timeStr === '09:48') {
                                        console.log(`🚨 ATTENTION: 09:48 bar has value ${point.value} - this should be the TALLEST in this group!`);
                                    }
                                });
                            }
                            
                            spurtBarSeries.setData(spurtData);
                            
                            // Force specific visible range for spurt bars to ensure proper scaling
                            setTimeout(() => {
                                try {
                                    const spurtScale = sentimentChart.priceScale('spurt-bars');
                                    const spurtValues = spurtData.map(d => d.value);
                                    const maxVal = Math.max(...spurtValues);
                                    const minVal = Math.min(...spurtValues, 0);
                                    
                                    // Force the visible range to match our data range
                                    spurtScale.applyOptions({
                                        autoScale: true,
                                        visible: true,
                                    });
                                    
                                    console.log(`🔧 Forced spurt scale range: ${minVal} to ${maxVal}`);
                                    console.log(`🔧 Spurt data values:`, spurtValues);
                                } catch (error) {
                                    console.error('❌ Error forcing spurt scale adjustment:', error);
                                }
                            }, 150);
                            
                            console.log(`✅ Spurt bar data updated: ${spurtData.length} points`);
                        } else {
                            console.warn('⚠️ No valid spurt data found for bar chart');
                        }
                        
                    } else {
                        // Remove bar series when not in zoom mode
                        if (sentimentBarSeries) {
                            console.log('📊 Removing sent bar chart for normal mode...');
                            sentimentChart.removeSeries(sentimentBarSeries);
                            sentimentBarSeries = null;
                            
                            // Remove sentiment zero line
                            if (sentimentZeroLine) {
                                sentimentChart.removeSeries(sentimentZeroLine);
                                sentimentZeroLine = null;
                            }
                            
                            // Clean up stored bar data
                            window.sentimentBarData = null;
                            
                            // Clean up tooltip
                            const tooltips = document.getElementById('sentiment-chart').querySelectorAll('div[style*="position: absolute"]');
                            tooltips.forEach(tooltip => {
                                if (tooltip.style.zIndex === '1000') {
                                    tooltip.remove();
                                }
                            });
                            
                            console.log('✅ Sentiment bar series and tooltip removed');
                        }

                        // Remove spurt bar series when not in zoom mode
                        if (spurtBarSeries) {
                            console.log('📊 Removing spurt bar chart for normal mode...');
                            sentimentChart.removeSeries(spurtBarSeries);
                            spurtBarSeries = null;
                            
                            // Remove spurt zero line
                            if (spurtZeroLine) {
                                sentimentChart.removeSeries(spurtZeroLine);
                                spurtZeroLine = null;
                            }
                            
                            // Clean up stored spurt data
                            window.spurtBarData = null;
                            
                            // Hide secondary data popup when exiting zoom mode
                            hideSecondaryDataPopup(true);
                            
                            console.log('✅ Spurt bar series removed');
                        }
                    }

                    // Update chart title based on mode
                    const titleElement = document.getElementById('sentiment-chart-title');
                    if (titleElement) {
                        if (isZoomMode) {
                            titleElement.textContent = '📊 Sentiment Analysis + Signal & Spurt Bars (Zoom Mode)';
                        } else {
                            titleElement.textContent = '📊 Sentiment Analysis (1-min)';
                        }
                    }

                    // Auto-fit the sentiment chart
                    setTimeout(() => {
                        try {
                            if (sentimentChart && sentimentChart.timeScale) {
                                sentimentChart.timeScale().fitContent();
                                console.log('✅ Sentiment Chart auto-fitted successfully');
                            }
                        } catch (error) {
                            console.error('❌ Sentiment Chart auto-fit failed:', error);
                        }
                    }, 100);

                    console.log('✅ Sentiment Chart updated successfully');
                } catch (error) {
                    console.error('❌ Error updating sentiment chart:', error);
                }
            }

            // Update OI Chart with data - ALWAYS uses 1-minute data regardless of current timeframe
            function updateOIChart() {
                console.log('📈 updateOIChart called - ALWAYS using 1-minute data');

                if (!oiChart || !callOISeries || !openInterestSeries) {
                    console.log('⚠️ OI Chart not initialized, skipping update');
                    return;
                }

                // ALWAYS use originalData (1-minute data) for OI chart
                const data = originalData;

                if (!data || data.length === 0) {
                    console.warn('⚠️ No 1-minute data available for OI chart');
                    return;
                }

                console.log(`📊 OI Chart using 1-minute data: ${data.length} points (current timeframe: ${currentTimeframe})`);

                // Prepare data for OI charts
                const callOIData = [];
                const openInterestData = [];
                data.forEach(point => {
                    const timePoint = point.time;

                    // Debug logging for first few points
                    if (callOIData.length < 3) {
                        console.log(`🔍 OI Debug - Point ${callOIData.length}:`, {
                            time: timePoint,
                            call_oi: point.call_oi,
                            open_interest: point.open_interest,
                            raw_point: point
                        });
                    }

                    // Add Call_OI data if available
                    if (point.call_oi !== undefined && !isNaN(point.call_oi)) {
                        callOIData.push({
                            time: timePoint,
                            value: point.call_oi
                        });
                    }

                    // Add open_interest data if available
                    if (point.open_interest !== undefined && !isNaN(point.open_interest)) {
                        openInterestData.push({
                            time: timePoint,
                            value: point.open_interest
                        });
                    }
                });
                console.log(`📊 OI Chart data prepared: ${callOIData.length} Call_OI points, ${openInterestData.length} Open Interest points`);

                // Debug: Show actual values
                if (callOIData.length > 0) {
                    console.log('📈 Call_OI sample values:', callOIData.slice(0, 3).map(d => d.value));
                }
                if (openInterestData.length > 0) {
                    console.log('📈 Open Interest sample values:', openInterestData.slice(0, 3).map(d => d.value));
                }

                if (callOIData.length === 0 && openInterestData.length === 0) {
                    console.warn('⚠️ No valid OI data found');
                    return;
                }

                // Update series data
                try {
                    if (callOIData.length > 0) {
                        callOISeries.setData(callOIData);
                        console.log('✅ Call_OI data updated');
                    }

                    if (openInterestData.length > 0) {
                        openInterestSeries.setData(openInterestData);
                        console.log('✅ Open Interest data updated');
                    }

                    // Auto-fit the OI chart
                    setTimeout(() => {
                        try {
                            if (oiChart && oiChart.timeScale) {
                                oiChart.timeScale().fitContent();
                                console.log('✅ OI Chart auto-fitted successfully');
                            }
                        } catch (error) {
                            console.error('❌ OI Chart auto-fit failed:', error);
                        }
                    }, 100);

                    console.log('✅ OI Chart updated successfully');
                } catch (error) {
                    console.error('❌ Error updating OI chart:', error);
                }
            }        // Update configuration based on selected index
            function updateIndexConfiguration(selectedIndex) {
                currentIndex = selectedIndex;
                const config = INDEX_CONFIG[currentIndex];

                // Update dynamic variables
                PRICE_DIVISOR = config.priceDivisor;
                VOLUME_BASELINE = config.volumeBaseline;
                IMPORTANT_CANDLE_THRESHOLD = PRICE_DIVISOR * 0.55;                // Update page title
                document.getElementById('dashboard-title').innerHTML = `
                <div class="title-main">
                    <div class="chart-mode-buttons">
                        <button class="chart-mode-btn active" data-mode="1" title="Main Chart (Double-click any button to show all charts)">1</button>
                        <button class="chart-mode-btn active" data-mode="2" title="OI Analysis Chart (Double-click any button to show all charts)">2</button>
                        <button class="chart-mode-btn active" data-mode="3" title="Sentiment Analysis Chart (Double-click any button to show all charts)">3</button>
                    </div>
                    📈 ${config.title} Dashboard
                    <div class="live-indicator"></div>
                </div>
                <div class="title-stats-inline">
                    <span class="title-stat">High: <span class="stat-value positive" id="day-high">₹--</span></span>
                    <span class="title-separator">↔</span>
                    <span class="title-stat">Low: <span class="stat-value negative" id="day-low">₹--</span></span>
                    <span class="title-separator">::</span>
                    <span class="data-date" id="data-date">--</span>
                </div>
            `;                console.log(`📊 Configuration updated for ${selectedIndex}:`, {
                    priceDivisor: PRICE_DIVISOR,
                    volumeBaseline: VOLUME_BASELINE,
                    threshold: IMPORTANT_CANDLE_THRESHOLD
                });

                // Update chart visibility after title update
                updateChartVisibility();
            }

            // Load data for selected index and date
            async function loadDataForIndexAndDate(index, dateString) {
                try {
                    // Generate filename based on index and date
                    const filename = generateFilename(index, dateString);

                    // Update the config with the new filename
                    INDEX_CONFIG[index].filename = filename;

                    console.log(`🔄 Loading ${index} data for ${dateString}`);
                    console.log(`📁 Filename: ${filename}`);

                    // Update global variables to ensure popup uses correct date
                    currentIndex = index;
                    currentDate = dateString;
                    console.log(`📅 Updated global currentDate to: ${currentDate}`);
                    console.log(`📊 Updated global currentIndex to: ${currentIndex}`);
                    console.log(`🚨 CRITICAL: currentDate variable is now set to "${currentDate}" for popup usage`);

                    // Clear secondary data cache for the new date
                    secondaryDataCache = {};
                    console.log(`🗑️ Cleared secondary data cache for fresh loading`);

                    // Update configuration
                    updateIndexConfiguration(index);

                    // Load the data
                    const data = await loadData();
                    if (data && data.length > 0) {
                        console.log(`📊 Loaded ${data.length} raw data points`);

                        // Clear original data cache to ensure fresh data
                        originalData = data;
                        const aggregatedData = aggregateData(data, currentTimeframe);

                        console.log(`📊 After aggregation to ${currentTimeframe}: ${aggregatedData.length} data points`);                      // Update chart and stats
                        updateChart(aggregatedData);
                        updateOIChart(aggregatedData);
                        updateSentimentChart(); // Always uses 1-minute data
                        updateStats(aggregatedData);

                        console.log(`✅ Successfully loaded ${index} data for ${dateString}`);
                        return true;
                    } else {
                        console.error(`❌ No data loaded`);
                        alert(`No data found for ${index} on ${dateString}. The CSV file might be empty or not exist.`);
                        return false;
                    }
                } catch (error) {
                    console.error(`❌ Error loading data:`, error);

                    if (error.message.includes('fetch')) {
                        alert(`File not found for ${index} on ${dateString}.\nExpected file: ${generateFilename(index, dateString)}`);
                    } else {
                        alert(`Failed to load data for ${index} on ${dateString}:\n${error.message}`);
                    }
                    return false;
                }
            }

            // Chart mode management functions
            // Function to trigger chart resize with more aggressive approach
            function triggerChartsResize() {
                console.log('📐 Triggering aggressive chart resize...');
                
                // Small delay to allow DOM to update first
                setTimeout(() => {
                    // Resize main chart if visible
                    const mainChartContainer = document.querySelector('.chart-container #chart');
                    if (mainChartContainer && mainChartContainer.offsetWidth > 0 && window.chart) {
                        console.log('📐 Resizing main chart');
                        window.chart.applyOptions({ 
                            width: mainChartContainer.clientWidth,
                            height: mainChartContainer.clientHeight
                        });
                    }
                    
                    // Resize OI chart if visible with aggressive sizing
                    const oiChartContainer = document.getElementById('oi-chart');
                    const oiChartElement = document.querySelector('.secondary-chart:nth-child(1)');
                    if (oiChartContainer && window.oiChart) {
                        console.log('📐 Aggressively resizing OI chart');
                        console.log('📐 OI Container dimensions:', {
                            clientWidth: oiChartContainer.clientWidth,
                            clientHeight: oiChartContainer.clientHeight,
                            offsetWidth: oiChartContainer.offsetWidth,
                            offsetHeight: oiChartContainer.offsetHeight
                        });
                        
                        const isFullSize = oiChartElement && oiChartElement.classList.contains('full-size');
                        console.log('📐 OI Chart is full-size:', isFullSize);
                        
                        let width, height;
                        
                        if (isFullSize) {
                            // Force full-size dimensions
                            width = Math.max(window.innerWidth - 320, 1000);
                            height = Math.max(window.innerHeight - 300, 600);
                            console.log('📐 OI Chart full-size mode:', { width, height, innerWidth: window.innerWidth, innerHeight: window.innerHeight });
                        } else {
                            // Use container dimensions
                            width = Math.max(oiChartContainer.clientWidth, 400);
                            height = Math.max(oiChartContainer.clientHeight, 300);
                            console.log('📐 OI Chart normal mode:', { width, height });
                        }
                        
                        // Force resize the chart with multiple attempts
                        window.oiChart.applyOptions({ width: 1, height: 1 }); // Force complete reset
                        setTimeout(() => {
                            window.oiChart.applyOptions({ width: width, height: height });
                            console.log('📐 OI Chart resized to:', { width, height });
                            
                            // Multiple auto-fit attempts with different methods
                            setTimeout(() => {
                                try {
                                    const timeScale = window.oiChart.timeScale();
                                    const priceScale = window.oiChart.priceScale('right');
                                    
                                    if (isFullSize) {
                                        // Apply multiple scaling methods for full-size mode
                                        console.log('📐 Applying aggressive scaling for OI Chart...');
                                        
                                        // Method 1: Basic fit
                                        timeScale.fitContent();
                                        
                                        // Method 2: Price scale auto-fit
                                        priceScale.applyOptions({
                                            autoScale: true,
                                        });
                                        
                                        // Method 3: Force chart redraw
                                        window.oiChart.applyOptions({
                                            layout: {
                                                backgroundColor: 'transparent',
                                                textColor: '#ffffff',
                                            }
                                        });
                                        
                                        // Method 4: Final fitContent
                                        setTimeout(() => {
                                            timeScale.fitContent();
                                            console.log('✅ OI Chart aggressively fitted to full area');
                                        }, 100);
                                        
                                    } else {
                                        timeScale.fitContent();
                                        priceScale.applyOptions({
                                            autoScale: true,
                                        });
                                        console.log('✅ OI Chart fitted to normal size');
                                    }
                                } catch (error) {
                                    console.error('❌ Error auto-fitting OI chart:', error);
                                }
                            }, 200); // Longer delay for better processing
                        }, 100); // Longer delay for reset
                    }
                    
                    // Resize sentiment chart if visible with aggressive sizing
                    const sentimentChartContainer = document.getElementById('sentiment-chart');
                    const sentimentChartElement = document.querySelector('.secondary-chart:nth-child(2)');
                    if (sentimentChartContainer && window.sentimentChart) {
                        console.log('📐 Aggressively resizing sentiment chart');
                        console.log('📐 Sentiment Container dimensions:', {
                            clientWidth: sentimentChartContainer.clientWidth,
                            clientHeight: sentimentChartContainer.clientHeight,
                            offsetWidth: sentimentChartContainer.offsetWidth,
                            offsetHeight: sentimentChartContainer.offsetHeight
                        });
                        
                        const isFullSize = sentimentChartElement && sentimentChartElement.classList.contains('full-size');
                        console.log('📐 Sentiment Chart is full-size:', isFullSize);
                        
                        let width, height;
                        
                        if (isFullSize) {
                            // Force full-size dimensions
                            width = Math.max(window.innerWidth - 320, 1000);
                            height = Math.max(window.innerHeight - 300, 600);
                            console.log('📐 Sentiment Chart full-size mode:', { width, height, innerWidth: window.innerWidth, innerHeight: window.innerHeight });
                        } else {
                            // Use container dimensions
                            width = Math.max(sentimentChartContainer.clientWidth, 400);
                            height = Math.max(sentimentChartContainer.clientHeight, 300);
                            console.log('📐 Sentiment Chart normal mode:', { width, height });
                        }
                        
                        // Force resize the chart with multiple attempts
                        window.sentimentChart.applyOptions({ width: 1, height: 1 }); // Force complete reset
                        setTimeout(() => {
                            window.sentimentChart.applyOptions({ width: width, height: height });
                            console.log('📐 Sentiment Chart resized to:', { width, height });
                            
                            // Multiple auto-fit attempts with different methods
                            setTimeout(() => {
                                try {
                                    const timeScale = window.sentimentChart.timeScale();
                                    const priceScale = window.sentimentChart.priceScale('right');
                                    
                                    if (isFullSize) {
                                        // Apply multiple scaling methods for full-size mode
                                        console.log('📐 Applying aggressive scaling for Sentiment Chart...');
                                        
                                        // Method 1: Basic fit
                                        timeScale.fitContent();
                                        
                                        // Method 2: Price scale auto-fit
                                        priceScale.applyOptions({
                                            autoScale: true,
                                        });
                                        
                                        // Method 3: Force chart redraw
                                        window.sentimentChart.applyOptions({
                                            layout: {
                                                backgroundColor: 'transparent',
                                                textColor: '#ffffff',
                                            }
                                        });
                                        
                                        // Method 4: Final fitContent
                                        setTimeout(() => {
                                            timeScale.fitContent();
                                            console.log('✅ Sentiment Chart aggressively fitted to full area');
                                        }, 100);
                                        
                                    } else {
                                        timeScale.fitContent();
                                        priceScale.applyOptions({
                                            autoScale: true,
                                        });
                                        console.log('✅ Sentiment Chart fitted to normal size');
                                    }
                                } catch (error) {
                                    console.error('❌ Error auto-fitting Sentiment chart:', error);
                                }
                            }, 200); // Longer delay for better processing
                        }, 100); // Longer delay for reset
                    }
                }, 100); // Small delay to allow layout changes to take effect
            }

            function updateChartVisibility() {
                console.log('👁️ Updating chart visibility for exclusive mode:', chartModes);
                
                // Get chart containers
                const mainChart = document.querySelector('.chart-container');
                const oiChart = document.querySelector('.secondary-chart:nth-child(1)');
                const sentimentChart = document.querySelector('.secondary-chart:nth-child(2)');
                const secondaryContainer = document.querySelector('.secondary-charts-container');
                const chartsContainer = document.querySelector('.charts-container');
                
                // Check if we're in "all charts" mode (initial state)
                const allEnabled = chartModes['1'] && chartModes['2'] && chartModes['3'];
                
                if (allEnabled) {
                    // Show all charts in original layout
                    console.log('📊 Displaying all charts (initial state)');
                    
                    // Reset all containers to original state
                    if (mainChart) {
                        mainChart.style.display = 'flex';
                        mainChart.style.flex = '1';
                        mainChart.style.minHeight = '';
                        mainChart.style.height = '';
                        mainChart.classList.remove('full-size');
                    }
                    
                    if (secondaryContainer) {
                        secondaryContainer.style.display = 'flex';
                        secondaryContainer.style.flex = '0 0 auto';
                        secondaryContainer.style.height = '';
                        secondaryContainer.style.width = '';
                        secondaryContainer.style.minHeight = '';
                        secondaryContainer.style.flexDirection = 'row'; // Reset to original direction
                        secondaryContainer.classList.remove('full-size-container');
                    }
                    
                    if (oiChart) {
                        oiChart.style.display = 'flex';
                        oiChart.style.flex = '';
                        oiChart.style.height = '';
                        oiChart.style.width = '';
                        oiChart.classList.remove('full-size');
                    }
                    
                    if (sentimentChart) {
                        sentimentChart.style.display = 'flex';
                        sentimentChart.style.flex = '';
                        sentimentChart.style.height = '';
                        sentimentChart.style.width = '';
                        sentimentChart.classList.remove('full-size');
                    }
                    
                    // Reset container styles for original layout
                    if (chartsContainer) {
                        chartsContainer.style.flexDirection = 'column';
                        chartsContainer.style.gap = '15px';
                    }
                    
                    // Force resize charts to fit their original containers
                    setTimeout(() => {
                        console.log('📐 Resizing charts for normal view...');
                        
                        // Resize main chart to fit its normal container
                        if (window.chart) {
                            const mainChartContainer = document.querySelector('.chart-container #chart');
                            if (mainChartContainer) {
                                window.chart.applyOptions({ 
                                    width: mainChartContainer.clientWidth,
                                    height: mainChartContainer.clientHeight
                                });
                            }
                        }
                        
                        // Resize OI chart to fit its normal container
                        if (window.oiChart) {
                            const oiChartContainer = document.getElementById('oi-chart');
                            if (oiChartContainer) {
                                const width = Math.max(oiChartContainer.clientWidth, 400);
                                const height = Math.max(oiChartContainer.clientHeight, 300);
                                window.oiChart.applyOptions({ width: width, height: height });
                                
                                // Fit content to normal size
                                setTimeout(() => {
                                    try {
                                        const timeScale = window.oiChart.timeScale();
                                        timeScale.fitContent();
                                        console.log('✅ OI Chart fitted to normal layout');
                                    } catch (error) {
                                        console.error('❌ Error fitting OI chart in normal mode:', error);
                                    }
                                }, 100);
                            }
                        }
                        
                        // Resize sentiment chart to fit its normal container  
                        if (window.sentimentChart) {
                            const sentimentChartContainer = document.getElementById('sentiment-chart');
                            if (sentimentChartContainer) {
                                const width = Math.max(sentimentChartContainer.clientWidth, 400);
                                const height = Math.max(sentimentChartContainer.clientHeight, 300);
                                window.sentimentChart.applyOptions({ width: width, height: height });
                                
                                // Fit content to normal size
                                setTimeout(() => {
                                    try {
                                        const timeScale = window.sentimentChart.timeScale();
                                        timeScale.fitContent();
                                        console.log('✅ Sentiment Chart fitted to normal layout');
                                    } catch (error) {
                                        console.error('❌ Error fitting Sentiment chart in normal mode:', error);
                                    }
                                }, 100);
                            }
                        }
                    }, 200); // Longer delay to ensure layout is fully reset
                    
                } else {
                    // Exclusive mode - show only selected chart, fill entire available space
                    console.log('📊 Exclusive mode - single chart display');
                    
                    if (chartModes['1']) {
                        // Show only main chart, fill entire space
                        console.log('📊 Showing only Main Chart - Full Size');
                        if (mainChart) {
                            mainChart.style.display = 'flex';
                            mainChart.style.flex = '1';
                            mainChart.style.height = '100%';
                            mainChart.style.minHeight = 'calc(100vh - 200px)'; // Account for header/controls
                            mainChart.classList.add('full-size');
                        }
                        if (secondaryContainer) {
                            secondaryContainer.style.display = 'none';
                        }
                        
                    } else if (chartModes['2']) {
                        // Show only OI chart, fill entire space
                        console.log('📊 Showing only OI Chart - Full Size');
                        if (mainChart) {
                            mainChart.style.display = 'none';
                            mainChart.classList.remove('full-size');
                        }
                        if (secondaryContainer) {
                            secondaryContainer.style.display = 'flex';
                            secondaryContainer.style.flex = '1';
                            secondaryContainer.style.height = 'calc(100vh - 200px)';
                            secondaryContainer.style.minHeight = 'calc(100vh - 200px)';
                            secondaryContainer.style.width = '100%';
                            secondaryContainer.style.flexDirection = 'column';
                            secondaryContainer.classList.add('full-size-container');
                        }
                        if (oiChart) {
                            oiChart.style.display = 'flex';
                            oiChart.style.flex = '1';
                            oiChart.style.height = 'calc(100vh - 200px)';
                            oiChart.style.width = '100%';
                            oiChart.classList.add('full-size');
                        }
                        if (sentimentChart) {
                            sentimentChart.style.display = 'none';
                            sentimentChart.classList.remove('full-size');
                        }
                        
                    } else if (chartModes['3']) {
                        // Show only sentiment chart, fill entire space
                        console.log('📊 Showing only Sentiment Chart - Full Size');
                        if (mainChart) {
                            mainChart.style.display = 'none';
                            mainChart.classList.remove('full-size');
                        }
                        if (secondaryContainer) {
                            secondaryContainer.style.display = 'flex';
                            secondaryContainer.style.flex = '1';
                            secondaryContainer.style.height = 'calc(100vh - 200px)';
                            secondaryContainer.style.minHeight = 'calc(100vh - 200px)';
                            secondaryContainer.style.width = '100%';
                            secondaryContainer.style.flexDirection = 'column';
                            secondaryContainer.classList.add('full-size-container');
                        }
                        if (oiChart) {
                            oiChart.style.display = 'none';
                            oiChart.classList.remove('full-size');
                        }
                        if (sentimentChart) {
                            sentimentChart.style.display = 'flex';
                            sentimentChart.style.flex = '1';
                            sentimentChart.style.height = 'calc(100vh - 200px)';
                            sentimentChart.style.width = '100%';
                            sentimentChart.classList.add('full-size');
                        }
                    }
                }
                
                // Trigger chart resize after layout changes
                triggerChartsResize();
                
                // Additional resize triggers with different timing to ensure proper scaling
                setTimeout(() => {
                    console.log('📐 Secondary resize trigger...');
                    triggerChartsResize();
                }, 300);
                
                setTimeout(() => {
                    console.log('📐 Final resize and scaling trigger...');
                    // Force additional fitContent for full-size charts
                    if (!allEnabled) {
                        if (chartModes['2'] && window.oiChart) {
                            try {
                                const timeScale = window.oiChart.timeScale();
                                timeScale.fitContent();
                                console.log('✅ Final OI Chart scaling applied');
                            } catch (error) {
                                console.error('❌ Error in final OI chart scaling:', error);
                            }
                        }
                        if (chartModes['3'] && window.sentimentChart) {
                            try {
                                const timeScale = window.sentimentChart.timeScale();
                                timeScale.fitContent();
                                console.log('✅ Final Sentiment Chart scaling applied');
                            } catch (error) {
                                console.error('❌ Error in final Sentiment chart scaling:', error);
                            }
                        }
                    }
                }, 600);
                
                // Update sentiment chart to show/hide bar chart based on mode
                setTimeout(() => {
                    console.log('📊 Updating sentiment chart for mode change...');
                    updateSentimentChart();
                }, 100);
                
                // Update button states
                document.querySelectorAll('.chart-mode-btn').forEach(btn => {
                    const mode = btn.dataset.mode;
                    
                    if (allEnabled) {
                        // All charts mode - all buttons active
                        btn.classList.add('active');
                        btn.classList.remove('disabled');
                        btn.disabled = false;
                    } else if (chartModes[mode]) {
                        // This is the selected chart - active
                        btn.classList.add('active');
                        btn.classList.remove('disabled');
                        btn.disabled = false;
                    } else {
                        // This chart is not selected - disabled
                        btn.classList.remove('active');
                        btn.classList.add('disabled');
                        btn.disabled = true;
                    }
                });
                
                console.log('✅ Chart visibility and sizing updated');
                
                // Debug logging
                console.log('🔍 Final visibility states:', {
                    mainChart: mainChart ? mainChart.style.display : 'not found',
                    secondaryContainer: secondaryContainer ? secondaryContainer.style.display : 'not found',
                    oiChart: oiChart ? oiChart.style.display : 'not found',
                    sentimentChart: sentimentChart ? sentimentChart.style.display : 'not found'
                });
            }

            function handleChartModeChange(mode) {
                console.log(`🔄 Chart mode ${mode} clicked - switching to exclusive view`);
                
                // Set all modes to false first
                chartModes['1'] = false;
                chartModes['2'] = false;
                chartModes['3'] = false;
                
                // Enable only the selected mode
                chartModes[mode] = true;
                
                console.log(`📊 Exclusive mode activated - Mode ${mode} only`);
                console.log(`� Chart modes:`, chartModes);
                
                // Update visibility
                updateChartVisibility();
                
                // Log the active chart
                const activeChart = mode === '1' ? 'Main Chart' : 
                                  mode === '2' ? 'OI Analysis' : 'Sentiment Analysis';
                console.log(`✅ Displaying only: ${activeChart}`);
                
                // Special debugging when switching to chart-3 (sentiment chart)
                if (mode === '3') {
                    console.log(`🚨 CHART-3 MODE ACTIVATED - DEBUGGING SENTIMENT CHART`);
                    console.log(`   📊 originalData length: ${originalData ? originalData.length : 'undefined'}`);
                    
                    if (originalData && originalData.length > 0) {
                        // Check for our problematic times in the data
                        const problematicTimes = ['09:18', '09:19', '09:20'];
                        problematicTimes.forEach(timeStr => {
                            const foundPoint = originalData.find(point => {
                                const date = new Date(point.time * 1000);
                                const pointTimeStr = date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                                return pointTimeStr === timeStr;
                            });
                            
                            if (foundPoint) {
                                console.log(`🚨 Found ${timeStr} in originalData: sent=${foundPoint.sent}, anamoly=${foundPoint.anamoly}`);
                            } else {
                                console.log(`❌ ${timeStr} NOT found in originalData`);
                            }
                        });
                        
                        // Trigger sentiment chart update with debugging
                        console.log(`🔄 Manually triggering updateSentimentChart() for debugging...`);
                        updateSentimentChart();
                    }
                }
            }        // Event listeners
            function setupEventListeners() {
                console.log('🎯 Starting setupEventListeners...');
                
                // Set default date to match available CSV file
                document.getElementById('date-select').value = currentDate;

                // Chart mode buttons event listener
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('chart-mode-btn') && !e.target.disabled) {
                        const mode = e.target.dataset.mode;
                        console.log(`📊 Chart mode button ${mode} clicked`);
                        handleChartModeChange(mode);
                    }
                });

                // Double-click to return to "all charts" view
                document.addEventListener('dblclick', (e) => {
                    if (e.target.classList.contains('chart-mode-btn')) {
                        console.log('🔄 Double-click detected - returning to all charts view');
                        
                        // Enable all charts
                        chartModes['1'] = true;
                        chartModes['2'] = true;
                        chartModes['3'] = true;
                        
                        updateChartVisibility();
                        console.log('✅ All charts view restored');
                    }
                });

                document.getElementById('index-select').addEventListener('change', async (e) => {
                    const selectedIndex = e.target.value;
                    const selectedDate = document.getElementById('date-select').value;

                    console.log(`� Index changed to: ${selectedIndex}`);
                    console.log(`� Using selected date: ${selectedDate}`);

                    const success = await loadDataForIndexAndDate(selectedIndex, selectedDate);

                    if (!success) {
                        // Revert to previous selection if loading fails
                        console.log(`🔄 Reverting index selection due to error`);
                        e.target.value = currentIndex;
                    }
                });

                // Date selector
                document.getElementById('date-select').addEventListener('change', async (e) => {
                    const selectedDate = e.target.value;
                    const selectedIndex = document.getElementById('index-select').value;

                    console.log(`📅 Date changed to: ${selectedDate}`);
                    console.log(`📊 Using current index: ${selectedIndex}`);

                    if (!selectedDate) {
                        console.warn('⚠️ No date selected');
                        return;
                    }

                    // Check if data exists for selected date
                    const dataExists = await checkDataExists(selectedIndex, selectedDate);

                    if (!dataExists) {
                        console.log('🔍 Data not found for selected date, finding most recent data...');
                        const mostRecentDate = await findMostRecentData(selectedIndex);

                        if (mostRecentDate) {
                            console.log(`📅 Found data for ${mostRecentDate}, using that instead`);
                            e.target.value = mostRecentDate;
                            await loadDataForIndexAndDate(selectedIndex, mostRecentDate);
                        } else {
                            const errorMessage = `No data files found for ${INDEX_CONFIG[selectedIndex].title} in the last 7 days.`;
                            console.error('❌ ' + errorMessage);
                            alert(errorMessage);
                            // Reset to current date
                            e.target.value = currentDate;
                        }
                    } else {
                        await loadDataForIndexAndDate(selectedIndex, selectedDate);
                    }
                });

                // Refresh button
                document.getElementById('refresh-btn').addEventListener('click', async () => {
                    console.log('🔄 Refresh button clicked');
                    const selectedDate = document.getElementById('date-select').value;
                    const selectedIndex = document.getElementById('index-select').value;

                    console.log(`🔄 Refreshing data for ${selectedIndex} on ${selectedDate}`);

                    // Add visual feedback - spin the icon
                    const refreshBtn = document.getElementById('refresh-btn');
                    const icon = refreshBtn.querySelector('svg');

                    refreshBtn.disabled = true;
                    icon.style.animation = 'spin 1s linear infinite';

                    try {
                        await loadDataForIndexAndDate(selectedIndex, selectedDate);
                        console.log('✅ Data refreshed successfully');
                    } catch (error) {
                        console.error('❌ Error refreshing data:', error);
                    } finally {
                        // Remove spinning animation and re-enable button
                        setTimeout(() => {
                            icon.style.animation = '';
                            refreshBtn.disabled = false;
                        }, 1000);
                    }
                });// Timeframe buttons
                document.querySelectorAll('.timeframe-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.timeframe-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        currentTimeframe = btn.dataset.timeframe;
                        const aggregatedData = aggregateData(originalData, currentTimeframe);
                        console.log(`🔄 Timeframe changed to ${currentTimeframe}, aggregated data length: ${aggregatedData.length}`);
                        updateChart(aggregatedData);
                        updateOIChart(); // OI chart always uses 1-minute data
                        updateSentimentChart(); // Sentiment chart always uses 1-minute data
                        updateStats(aggregatedData);
                    });
                });// Zoom controls
                document.getElementById('zoom-in').addEventListener('click', () => {
                    console.log('🔍 Zoom in button clicked');
                    if (chart && chart.timeScale && typeof chart.timeScale === 'function') {
                        try {
                            const timeScale = chart.timeScale();
                            const visibleRange = timeScale.getVisibleRange();

                            if (visibleRange) {
                                const rangeSize = visibleRange.to - visibleRange.from;
                                const center = (visibleRange.from + visibleRange.to) / 2;
                                const newRangeSize = rangeSize * 0.7; // Zoom in by 30%

                                timeScale.setVisibleRange({
                                    from: center - newRangeSize / 2,
                                    to: center + newRangeSize / 2
                                });
                                console.log('✅ Zoomed in successfully');
                            } else {
                                console.error('❌ Could not get visible range');
                            }
                        } catch (error) {
                            console.error('❌ Error zooming in:', error);
                        }
                    } else {
                        console.error('❌ Chart or timeScale not properly initialized');
                    }
                });

                document.getElementById('zoom-out').addEventListener('click', () => {
                    console.log('🔍 Zoom out button clicked');
                    if (chart && chart.timeScale && typeof chart.timeScale === 'function') {
                        try {
                            const timeScale = chart.timeScale();
                            const visibleRange = timeScale.getVisibleRange();

                            if (visibleRange) {
                                const rangeSize = visibleRange.to - visibleRange.from;
                                const center = (visibleRange.from + visibleRange.to) / 2;
                                const newRangeSize = rangeSize * 1.4; // Zoom out by 40%

                                timeScale.setVisibleRange({
                                    from: center - newRangeSize / 2,
                                    to: center + newRangeSize / 2
                                });
                                console.log('✅ Zoomed out successfully');
                            } else {
                                console.error('❌ Could not get visible range');
                            }
                        } catch (error) {
                            console.error('❌ Error zooming out:', error);
                        }
                    } else {
                        console.error('❌ Chart or timeScale not properly initialized');
                    }
                }); document.getElementById('fit-content').addEventListener('click', () => {
                    console.log('📏 Fit content button clicked');
                    if (chart && chart.timeScale && originalData && originalData.length > 0) {
                        try {
                            const timeScale = chart.timeScale();
                            const aggregatedData = aggregateData(originalData, currentTimeframe);

                            if (aggregatedData && aggregatedData.length > 0) {
                                // Use enhanced fit logic like in auto-fit
                                const firstTime = aggregatedData[0].time;
                                const lastTime = aggregatedData[aggregatedData.length - 1].time;
                                const timeRange = lastTime - firstTime;
                                const padding = Math.max(timeRange * 0.05, 300);

                                timeScale.setVisibleRange({
                                    from: firstTime - padding,
                                    to: lastTime + padding
                                });

                                console.log('✅ Enhanced fit content applied');
                            } else {
                                // Fallback to standard fitContent
                                timeScale.fitContent();
                                console.log('✅ Standard fit content applied');
                            }
                        } catch (error) {
                            console.error('❌ Error fitting content:', error);
                        }
                    } else {
                        console.error('❌ Chart, timeScale, or data not available');
                    }
                });
                
                // Popup event listeners
                
                // ESC key to close locked popup
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && isPopupLocked) {
                        console.log('🔓 ESC pressed - closing locked popup');
                        hideSecondaryDataPopup(false, true); // force close
                    }
                    
                    // TEST: Press 'L' key to toggle lock (for debugging)
                    if (e.key === 'l' || e.key === 'L') {
                        console.log('🧪 L key pressed - toggling lock');
                        if (!secondaryDataPopup) {
                            secondaryDataPopup = document.getElementById('secondary-data-popup');
                        }
                        
                        if (isPopupLocked) {
                            unlockPopup();
                        } else {
                            lockPopup();
                        }
                    }
                });
                
                // Try to initialize popup listeners immediately
                initializePopupEventListeners();
                
                // Also try after a delay to ensure DOM is ready
                setTimeout(() => {
                    initializePopupEventListeners();
                }, 500);
                
                console.log('✅ Popup event listeners setup completed');
                
                // Test if popup element exists
                const testPopup = document.getElementById('secondary-data-popup');
                console.log('🧪 Popup element found:', !!testPopup);
                if (testPopup) {
                    console.log('🧪 Popup element classes:', testPopup.className);
                } else {
                    console.error('❌ Popup element not found!');
                }
            }
            
            // Debug/Test Functions
            let testPopupLocked = false;
            
            function addDebugLog(message) {
                const logDiv = document.getElementById('debug-log');
                if (logDiv) {
                    const time = new Date().toLocaleTimeString();
                    logDiv.innerHTML += `<div>[${time}] ${message}</div>`;
                    logDiv.scrollTop = logDiv.scrollHeight;
                }
                console.log(message);
            }
            
            function testPopupLock() {
                addDebugLog('🧪 Manual lock/unlock test');
                const statusDiv = document.getElementById('debug-status');
                
                if (isPopupLocked) {
                    unlockPopup();
                    statusDiv.textContent = 'Status: Unlocked';
                    addDebugLog('🔓 Manual unlock completed');
                } else {
                    lockPopup();
                    statusDiv.textContent = 'Status: Locked';
                    addDebugLog('🔒 Manual lock completed');
                }
            }

            // Debug function to test server file access
            async function testServerFileAccess() {
                console.log('🧪 Testing server file access...');
                
                try {
                    // Test the debug endpoint
                    const response = await fetch('/debug/summary-files');
                    if (response.ok) {
                        const data = await response.json();
                        console.log('📁 Summary files found on server:', data);
                        return data;
                    } else {
                        console.error('❌ Failed to access debug endpoint:', response.status);
                    }
                } catch (error) {
                    console.error('❌ Error testing server access:', error);
                }
                
                return null;
            }

            // Main initialization
            async function initialize() {
                try {
                    console.log('🚀 Starting dashboard initialization...');

                    // Check if LightweightCharts is loaded
                    if (typeof LightweightCharts === 'undefined') {
                        console.error('❌ LightweightCharts library not loaded!');
                        return;
                    }

                    console.log('✅ LightweightCharts library loaded');

                    initializeChart();
                    initializeOIChart();
                    initializeSentimentChart();
                    setupEventListeners();

                    // Initialize chart visibility with default state (all enabled)
                    updateChartVisibility();

                    // Find most recent available data
                    console.log('🔍 Finding most recent data...');
                    const mostRecentDate = await findMostRecentData(currentIndex);

                    if (mostRecentDate) {
                        currentDate = mostRecentDate;

                        // Update the date input field
                        document.getElementById('date-select').value = mostRecentDate;

                        console.log(`📅 Using most recent data: ${mostRecentDate}`);
                        console.log('📊 Current configuration:', {
                            currentIndex,
                            currentDate,
                            expectedFilename: generateFilename(currentIndex, currentDate)
                        });

                        const success = await loadDataForIndexAndDate(currentIndex, mostRecentDate);

                        if (success) {
                            console.log(`✅ ${INDEX_CONFIG[currentIndex].title} Dashboard initialized successfully`);
                        } else {
                            console.warn('⚠️ Dashboard initialized but data loading failed');
                        }
                    } else {
                        // No data found in last 7 days
                        const errorMessage = `No data files found for ${INDEX_CONFIG[currentIndex].title} in the last 7 days. Please check if data files are available.`;
                        console.error('❌ ' + errorMessage);
                        alert(errorMessage);

                        // Set today's date as fallback
                        const today = new Date().toISOString().split('T')[0];
                        currentDate = today;
                        document.getElementById('date-select').value = today;
                    }
                } catch (error) {
                    console.error('❌ Dashboard initialization failed:', error);
                    alert(`Dashboard initialization failed: ${error.message}`);
                }
            }

            // Start when page loads
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initialize);
            } else {
                initialize();
            }
        </script>

        <!-- Secondary Data Popup -->
        <div id="secondary-data-popup" class="secondary-data-popup">
            <div class="popup-header">
                <div id="popup-title">📊 Options Data Details</div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <button id="popup-lock-btn" class="popup-close" onclick="togglePopupLock()" title="Click to lock/unlock popup (L key also works)" style="font-size: 14px;">🔓</button>
                    <button class="popup-close" onclick="hideSecondaryDataPopup(false, true)" title="Close popup (ESC key also works)">&times;</button>
                </div>
            </div>
            <div id="secondary-data-content">
                <div class="no-data">
                    <div>Hover over a signal bar to see options data</div>
                    <div style="font-size: 10px; color: #64748b; margin-top: 8px;">
                        💡 Click 🔓 button or press 'L' key to lock • Right-click popup to toggle lock • ESC to close
                    </div>
                </div>
            </div>
        </div>

    </body>

</html>